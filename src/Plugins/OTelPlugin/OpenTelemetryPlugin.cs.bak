// Copyright (C) 2015-2025 The Neo Project.
//
// OpenTelemetryPlugin.cs file belongs to the neo project and is free
// software distributed under the MIT software license, see the
// accompanying file LICENSE in the main directory of the
// repository or http://www.opensource.org/licenses/mit-license.php
// for more details.
//
// Redistribution and use in source and binary forms with or without
// modifications are permitted.

using Akka.Actor;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Neo;
using Neo.ConsoleService;
using Neo.IEventHandlers;
using Neo.Ledger;
using Neo.Network.P2P;
using Neo.Network.P2P.Payloads;
using Neo.Persistence;
using Neo.Plugins.OpenTelemetry.Collectors;
using Neo.Plugins.OpenTelemetry.Metrics;
using Neo.Plugins.OpenTelemetry.Tracers;
using Neo.SmartContract;
using Neo.VM;
using Neo.VM.Types;
using OpenTelemetry;
using OpenTelemetry.Exporter;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;
using System.Diagnostics;
using System.Diagnostics.Metrics;

namespace Neo.Plugins.OpenTelemetry
{
    public class OpenTelemetryPlugin : Plugin, ICommittedHandler, ITransactionAddedHandler, ITransactionRemovedHandler, ILoggingHandler
    {
        private OpenTelemetrySettings? _settings;
        private MetricsCollector? _collector;
        private NeoMetrics? _metrics;
        private NeoTracer? _tracer;
        private IHost? _metricsHost;
        private NeoSystem? _neoSystem;
        private TracerProvider? _tracerProvider;
        private MeterProvider? _meterProvider;
        private ILoggerFactory? _loggerFactory;

        public override string Name => "OpenTelemetry";
        public override string Description => "Provides comprehensive observability for Neo blockchain node using OpenTelemetry standards";
        protected override UnhandledExceptionPolicy ExceptionPolicy => UnhandledExceptionPolicy.StopPlugin;

        protected override void Configure()
        {
            var config = GetConfiguration();
            _settings = OpenTelemetrySettings.Load(config);
            
            if (_settings?.Enabled != true)
            {
                ConsoleHelper.Warning("OpenTelemetry plugin is disabled in configuration");
                return;
            }
        }

        protected override void OnSystemLoaded(NeoSystem system)
        {
            if (_settings?.Enabled != true) return;

            _neoSystem = system;
            
            // Create resource attributes
            var resourceBuilder = ResourceBuilder.CreateDefault()
                .AddService(
                    serviceName: _settings.ServiceName,
                    serviceVersion: _settings.ServiceVersion,
                    serviceInstanceId: string.IsNullOrEmpty(_settings.InstanceId) ? Environment.MachineName : _settings.InstanceId)
                .AddTelemetrySdk();

            // Add custom resource attributes
            foreach (var attr in _settings.ResourceAttributes)
            {
                resourceBuilder.AddAttributes(new[] { new KeyValuePair<string, object>(attr.Key, attr.Value) });
            }

            var resource = resourceBuilder.Build();

            // Initialize metrics
            if (_settings.Metrics.Enabled)
            {
                InitializeMetrics(resource);
            }

            // Initialize tracing
            if (_settings.Tracing.Enabled)
            {
                InitializeTracing(resource);
            }

            // Initialize logging
            if (_settings.Logging.Enabled)
            {
                InitializeLogging(resource);
            }

            // Subscribe to Neo events
            SubscribeToEvents();

            ConsoleHelper.Info($"OpenTelemetry plugin initialized - Service: {_settings.ServiceName}");
        }

        private void InitializeMetrics(Resource resource)
        {
            if (_settings == null) return;

            var meterProviderBuilder = Sdk.CreateMeterProviderBuilder()
                .SetResourceBuilder(ResourceBuilder.CreateEmpty().AddAttributes(resource.Attributes))
                .AddMeter("Neo.Blockchain")
                .AddRuntimeInstrumentation();

            // Configure exporters
            if (_settings.OtlpExporter.Enabled && _settings.OtlpExporter.ExportMetrics)
            {
                meterProviderBuilder.AddOtlpExporter(options =>
                {
                    options.Endpoint = new Uri(_settings.OtlpExporter.Endpoint);
                    options.Protocol = _settings.OtlpExporter.Protocol.ToLower() == "grpc" 
                        ? OtlpExportProtocol.Grpc 
                        : OtlpExportProtocol.HttpProtobuf;
                    options.TimeoutMilliseconds = _settings.OtlpExporter.Timeout;
                    
                    if (!string.IsNullOrEmpty(_settings.OtlpExporter.Headers))
                    {
                        options.Headers = _settings.OtlpExporter.Headers;
                    }
                });
            }

            if (_settings.Metrics.ConsoleExporter.Enabled)
            {
                meterProviderBuilder.AddConsoleExporter();
            }

            _meterProvider = meterProviderBuilder.Build();
            _collector = new MetricsCollector(_neoSystem!);
            _metrics = new NeoMetrics("Neo.Blockchain", "1.0.0", _collector);

            // Start Prometheus endpoint if enabled
            if (_settings.Metrics.PrometheusExporter.Enabled)
            {
                StartPrometheusEndpoint();
            }
        }

        private void InitializeTracing(Resource resource)
        {
            if (_settings == null) return;

            var tracerProviderBuilder = Sdk.CreateTracerProviderBuilder()
                .SetResourceBuilder(ResourceBuilder.CreateEmpty().AddAttributes(resource.Attributes))
                .AddSource("Neo.*")
                .SetSampler(new TraceIdRatioBasedSampler(_settings.Tracing.SamplingRatio));

            // Configure exporters
            if (_settings.OtlpExporter.Enabled && _settings.OtlpExporter.ExportTraces)
            {
                tracerProviderBuilder.AddOtlpExporter(options =>
                {
                    options.Endpoint = new Uri(_settings.OtlpExporter.Endpoint);
                    options.Protocol = _settings.OtlpExporter.Protocol.ToLower() == "grpc" 
                        ? OtlpExportProtocol.Grpc 
                        : OtlpExportProtocol.HttpProtobuf;
                    options.TimeoutMilliseconds = _settings.OtlpExporter.Timeout;
                    
                    if (!string.IsNullOrEmpty(_settings.OtlpExporter.Headers))
                    {
                        options.Headers = _settings.OtlpExporter.Headers;
                    }
                });
            }

            if (_settings.Tracing.ConsoleExporter.Enabled)
            {
                tracerProviderBuilder.AddConsoleExporter();
            }

            _tracerProvider = tracerProviderBuilder.Build();
            _tracer = new NeoTracer();
        }

        private void InitializeLogging(Resource resource)
        {
            if (_settings == null) return;

            _loggerFactory = LoggerFactory.Create(builder =>
            {
                builder.AddOpenTelemetry(options =>
                {
                    options.SetResourceBuilder(ResourceBuilder.CreateEmpty().AddAttributes(resource.Attributes));
                    options.IncludeScopes = _settings.Logging.IncludeScopes;
                    options.IncludeFormattedMessage = _settings.Logging.IncludeFormattedMessage;

                    if (_settings.OtlpExporter.Enabled && _settings.OtlpExporter.ExportLogs)
                    {
                        options.AddOtlpExporter(otlpOptions =>
                        {
                            otlpOptions.Endpoint = new Uri(_settings.OtlpExporter.Endpoint);
                            otlpOptions.Protocol = _settings.OtlpExporter.Protocol.ToLower() == "grpc" 
                                ? OtlpExportProtocol.Grpc 
                                : OtlpExportProtocol.HttpProtobuf;
                            otlpOptions.TimeoutMilliseconds = _settings.OtlpExporter.Timeout;
                            
                            if (!string.IsNullOrEmpty(_settings.OtlpExporter.Headers))
                            {
                                otlpOptions.Headers = _settings.OtlpExporter.Headers;
                            }
                        });
                    }

                    if (_settings.Logging.ConsoleExporter.Enabled)
                    {
                        options.AddConsoleExporter();
                    }
                });
            });
        }

        private void StartPrometheusEndpoint()
        {
            if (_settings == null) return;

            _metricsHost = Host.CreateDefaultBuilder()
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseUrls($"http://+:{_settings.Metrics.PrometheusExporter.Port}");
                    webBuilder.Configure(app =>
                    {
                        app.UseOpenTelemetryPrometheusScrapingEndpoint(
                            context => context.Request.Path == _settings.Metrics.PrometheusExporter.Path);
                    });
                })
                .Build();

            _metricsHost.RunAsync();
            ConsoleHelper.Info($"Prometheus metrics endpoint started at http://localhost:{_settings.Metrics.PrometheusExporter.Port}{_settings.Metrics.PrometheusExporter.Path}");
        }

        private void SubscribeToEvents()
        {
            if (_neoSystem == null) return;

            // Subscribe to blockchain events
            Blockchain.Committing += OnCommitting;
            Blockchain.Committed += OnCommitted;
        }

        void ICommittedHandler.Blockchain_Committed(NeoSystem system, Block block)
        {
            if (_metrics == null || _tracer == null) return;

            using var activity = _tracer.BlockActivity.StartActivity("BlockCommitted");
            activity?.SetTag("block.height", block.Index);
            activity?.SetTag("block.hash", block.Hash.ToString());
            activity?.SetTag("block.transactions", block.Transactions.Length);

            // Update metrics
            _metrics.BlocksProcessed.Add(1);
            _metrics.TransactionsProcessed.Add(block.Transactions.Length);
            _metrics.TransactionsPerBlock.Record(block.Transactions.Length);

            // Record block processing time if we have the start time
            if (activity != null && activity.StartTimeUtc != default)
            {
                var processingTime = (DateTimeOffset.UtcNow - activity.StartTimeUtc).TotalMilliseconds;
                _metrics.BlockProcessingTime.Record(processingTime);
            }
        }

        void ITransactionAddedHandler.MemoryPool_TransactionAdded(NeoSystem system, Transaction transaction)
        {
            if (_metrics == null || _tracer == null) return;

            using var activity = _tracer.TransactionActivity.StartActivity("TransactionAdded");
            activity?.SetTag("tx.hash", transaction.Hash.ToString());
            activity?.SetTag("tx.size", transaction.Size);
            activity?.SetTag("tx.network_fee", transaction.NetworkFee);
            activity?.SetTag("tx.system_fee", transaction.SystemFee);

            _metrics.TransactionsAdded.Add(1);
        }

        void ITransactionRemovedHandler.MemoryPool_TransactionRemoved(NeoSystem system, MemoryPoolTxRemovalReason reason, Transaction transaction)
        {
            if (_metrics == null) return;

            _metrics.TransactionsRemoved.Add(1, new KeyValuePair<string, object?>("reason", reason.ToString()));
        }

        void ILoggingHandler.Utility_Logging_Handler(string source, LogLevel level, object message)
        {
            if (_loggerFactory == null) return;

            var logger = _loggerFactory.CreateLogger(source);
            var logMessage = message?.ToString() ?? string.Empty;

            switch (level)
            {
                case LogLevel.Debug:
                    logger.LogDebug(logMessage);
                    break;
                case LogLevel.Information:
                    logger.LogInformation(logMessage);
                    break;
                case LogLevel.Warning:
                    logger.LogWarning(logMessage);
                    break;
                case LogLevel.Error:
                    logger.LogError(logMessage);
                    break;
                case LogLevel.Critical:
                    logger.LogCritical(logMessage);
                    break;
            }
        }

        private void OnCommitting(NeoSystem system, Block block, DataCache snapshot, IReadOnlyList<ApplicationEngine.ApplicationExecuted> applicationExecutedList)
        {
            if (_metrics == null || _tracer == null) return;

            using var activity = _tracer.BlockActivity.StartActivity("BlockCommitting");
            activity?.SetTag("block.height", block.Index);
            activity?.SetTag("block.hash", block.Hash.ToString());

            // Track smart contract executions
            foreach (var appExec in applicationExecutedList)
            {
                _metrics.ContractInvocations.Add(1);
                _metrics.GasConsumed.Add(appExec.GasConsumed);

                if (appExec.VMState == VMState.FAULT)
                {
                    _metrics.ContractFaults.Add(1);
                }
            }
        }

        private void OnCommitted(NeoSystem system, Block block)
        {
            // Additional committed event handling if needed
        }


        public override void Dispose()
        {
            // Unsubscribe from events
            Blockchain.Committing -= OnCommitting;
            Blockchain.Committed -= OnCommitted;

            // Dispose OpenTelemetry providers
            _tracerProvider?.Dispose();
            _meterProvider?.Dispose();
            _loggerFactory?.Dispose();
            _metricsHost?.StopAsync(TimeSpan.FromSeconds(5)).Wait();
            _metricsHost?.Dispose();

            base.Dispose();
        }

        // Console commands for runtime control
        [ConsoleCommand("telemetry enable", Category = "OpenTelemetry", Description = "Enable telemetry collection")]
        private void EnableTelemetry()
        {
            if (_settings == null)
            {
                ConsoleHelper.Error("OpenTelemetry settings not loaded");
                return;
            }

            _settings = _settings with { Enabled = true };
            OnSystemLoaded(_neoSystem!);
            ConsoleHelper.Info("Telemetry enabled");
        }

        [ConsoleCommand("telemetry disable", Category = "OpenTelemetry", Description = "Disable telemetry collection")]
        private void DisableTelemetry()
        {
            Dispose();
            ConsoleHelper.Info("Telemetry disabled");
        }

        [ConsoleCommand("telemetry status", Category = "OpenTelemetry", Description = "Show telemetry status")]
        private void ShowTelemetryStatus()
        {
            ConsoleHelper.Info($"OpenTelemetry Status:");
            ConsoleHelper.Info($"  Enabled: {_settings?.Enabled ?? false}");
            ConsoleHelper.Info($"  Service: {_settings?.ServiceName ?? "N/A"}");
            ConsoleHelper.Info($"  Metrics: {_settings?.Metrics.Enabled ?? false}");
            ConsoleHelper.Info($"  Tracing: {_settings?.Tracing.Enabled ?? false}");
            ConsoleHelper.Info($"  Logging: {_settings?.Logging.Enabled ?? false}");
            
            if (_settings?.Metrics.PrometheusExporter.Enabled == true)
            {
                ConsoleHelper.Info($"  Prometheus endpoint: http://localhost:{_settings.Metrics.PrometheusExporter.Port}{_settings.Metrics.PrometheusExporter.Path}");
            }
        }
    }
}