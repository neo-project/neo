<?xml version="1.0"?>
<doc>
    <assembly>
        <name>RpcServer</name>
    </assembly>
    <members>
        <member name="T:Neo.Plugins.RpcServer.Model.Address">
            <summary>
            A record that contains an address for jsonrpc.
            This represents an address that can be either  UInt160 or Base58Check format when specifying a JSON-RPC method.
            </summary>
            <param name="ScriptHash">The script hash of the address.</param>
            <param name="AddressVersion">The address version of the address.</param>
        </member>
        <member name="M:Neo.Plugins.RpcServer.Model.Address.#ctor(Neo.UInt160,System.Byte)">
            <summary>
            A record that contains an address for jsonrpc.
            This represents an address that can be either  UInt160 or Base58Check format when specifying a JSON-RPC method.
            </summary>
            <param name="ScriptHash">The script hash of the address.</param>
            <param name="AddressVersion">The address version of the address.</param>
        </member>
        <member name="P:Neo.Plugins.RpcServer.Model.Address.ScriptHash">
            <summary>The script hash of the address.</summary>
        </member>
        <member name="P:Neo.Plugins.RpcServer.Model.Address.AddressVersion">
            <summary>The address version of the address.</summary>
        </member>
        <member name="M:Neo.Plugins.RpcServer.Model.ContractNameOrHashOrId.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="id">Contract Id</param>
        </member>
        <member name="M:Neo.Plugins.RpcServer.Model.ContractNameOrHashOrId.#ctor(Neo.UInt160)">
            <summary>
            Constructor
            </summary>
            <param name="hash">Contract hash</param>
        </member>
        <member name="M:Neo.Plugins.RpcServer.Model.ContractNameOrHashOrId.#ctor(System.String)">
            <summary>
             The name is one of the native contract names:
             ContractManagement, StdLib, CryptoLib, LedgerContract, NeoToken, GasToken, PolicyContract, RoleManagement, OracleContract, Notary
            <para>
             Or use `list nativecontract` in neo-cli to get the native contract names.
            </para>
            </summary>
            <param name="nameOrId">Contract Name or Id</param>
        </member>
        <member name="T:Neo.Plugins.RpcServer.Model.SignersAndWitnesses">
            <summary>
            A record that contains signers and witnesses for jsonrpc.
            This represents a list of signers that may contain witness info when specifying a JSON-RPC method.
            <see cref="M:Neo.Plugins.RpcServer.ParameterConverter.ToSignersAndWitnesses(Neo.Json.JToken,System.Byte)"/>
            </summary>
            <param name="Signers">The signers to be used in the transaction.</param>
            <param name="Witnesses">The witnesses to be used in the transaction.</param>
        </member>
        <member name="M:Neo.Plugins.RpcServer.Model.SignersAndWitnesses.#ctor(Neo.Network.P2P.Payloads.Signer[],Neo.Network.P2P.Payloads.Witness[])">
            <summary>
            A record that contains signers and witnesses for jsonrpc.
            This represents a list of signers that may contain witness info when specifying a JSON-RPC method.
            <see cref="M:Neo.Plugins.RpcServer.ParameterConverter.ToSignersAndWitnesses(Neo.Json.JToken,System.Byte)"/>
            </summary>
            <param name="Signers">The signers to be used in the transaction.</param>
            <param name="Witnesses">The witnesses to be used in the transaction.</param>
        </member>
        <member name="P:Neo.Plugins.RpcServer.Model.SignersAndWitnesses.Signers">
            <summary>The signers to be used in the transaction.</summary>
        </member>
        <member name="P:Neo.Plugins.RpcServer.Model.SignersAndWitnesses.Witnesses">
            <summary>The witnesses to be used in the transaction.</summary>
        </member>
        <member name="M:Neo.Plugins.RpcServer.ParameterConverter.RegisterConversion``1(System.Func{Neo.Json.JToken,System.Object})">
            <summary>
            Registers a conversion function for a specific type.
            If a convert method needs more than one parameter, use a lambda expression to pass the parameters.
            </summary>
            <typeparam name="T">The type to register the conversion function for.</typeparam>
            <param name="conversion">The conversion function to register.</param>
        </member>
        <member name="M:Neo.Plugins.RpcServer.ParameterConverter.ToSignersAndWitnesses(Neo.Json.JToken,System.Byte)">
            <summary>
            Create a SignersAndWitnesses from a JSON array.
            Each item in the JSON array should be a JSON object with the following properties:
            - "signer": A JSON object with the following properties:
              - "account": A hex-encoded UInt160 or a Base58Check address, required.
              - "scopes": A enum string representing the scopes(WitnessScope) of the signer, required.
              - "allowedcontracts": An array of hex-encoded UInt160, optional.
              - "allowedgroups": An array of hex-encoded ECPoint, optional.
              - "rules": An array of strings representing the rules(WitnessRule) of the signer, optional.
            - "witness": A JSON object with the following properties:
              - "invocation": A base64-encoded string representing the invocation script, optional.
              - "verification": A base64-encoded string representing the verification script, optional.
            </summary>
            <param name="json">The JSON array to create a SignersAndWitnesses from.</param>
            <param name="addressVersion">The address version to use for the signers.</param>
            <returns>A SignersAndWitnesses object.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">Thrown when the JSON array is invalid.</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.ParameterConverter.ToSigner(Neo.Json.JToken,System.Byte)">
            <summary>
            Create a Signer from a JSON object.
            The JSON object should have the following properties:
            - "account": A hex-encoded UInt160 or a Base58Check address, required.
            - "scopes": A enum string representing the scopes(WitnessScope) of the signer, required.
            - "allowedcontracts": An array of hex-encoded UInt160, optional.
            - "allowedgroups": An array of hex-encoded ECPoint, optional.
            - "rules": An array of strings representing the rules(WitnessRule) of the signer, optional.
            </summary>
            <param name="json">The JSON object to create a Signer from.</param>
            <param name="addressVersion">The address version to use for the signer.</param>
            <returns>A Signer object.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">Thrown when the JSON object is invalid.</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.ParameterConverter.ToSigners(Neo.Json.JArray,System.Byte)">
            <summary>
            Create a Signer array from a JSON array.
            Each item in the JSON array should be a JSON object with the following properties:
            - "account": A hex-encoded UInt160 or a Base58Check address, required.
            - "scopes": A enum string representing the scopes(WitnessScope) of the signer, required.
            - "allowedcontracts": An array of hex-encoded UInt160, optional.
            - "allowedgroups": An array of hex-encoded ECPoint, optional.
            - "rules": An array of strings representing the rules(WitnessRule) of the signer, optional.
            </summary>
            <param name="json">The JSON array to create a Signer array from.</param>
            <param name="addressVersion">The address version to use for the signers.</param>
            <returns>A Signer array.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">Thrown when the JSON array is invalid or max allowed witness exceeded.</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.ParameterConverter.ToWitnesses(Neo.Json.JArray)">
            <summary>
            Create a Witness array from a JSON array.   
            Each item in the JSON array should be a JSON object with the following properties:
            - "invocation": A base64-encoded string representing the invocation script, optional.
            - "verification": A base64-encoded string representing the verification script, optional.
            </summary>
            <param name="json">The JSON array to create a Witness array from.</param>
            <returns>A Witness array.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">Thrown when the JSON array is invalid or max allowed witness exceeded.</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.ParameterConverter.AddressToScriptHash(System.String,System.Byte)">
            <summary>
            Converts an hex-encoded UInt160 or a Base58Check address to a script hash.
            </summary>
            <param name="address">The address to convert.</param>
            <param name="version">The address version to use for the conversion.</param>
            <returns>The script hash corresponding to the address.</returns>
        </member>
        <member name="P:Neo.Plugins.RpcServer.RpcServersSettings.KeepAliveTimeout">
            <summary>
            The maximum time in seconds allowed for the keep-alive connection to be idle.
            </summary>
        </member>
        <member name="P:Neo.Plugins.RpcServer.RpcServersSettings.RequestHeadersTimeout">
            <summary>
            The maximum time in seconds allowed for the request headers to be read.
            </summary>
        </member>
        <member name="P:Neo.Plugins.RpcServer.RpcServersSettings.MaxGasInvoke">
            <summary>
            In the unit of datoshi, 1 GAS = 10^8 datoshi
            </summary>
        </member>
        <member name="P:Neo.Plugins.RpcServer.RpcServersSettings.MaxFee">
            <summary>
            In the unit of datoshi, 1 GAS = 10^8 datoshi
            </summary>
        </member>
        <member name="M:Neo.Plugins.RpcServer.Result.Ok_Or``1(System.Func{``0},Neo.Plugins.RpcServer.RpcError,System.Boolean)">
            <summary>
            Checks the execution result of a function and throws an exception if it is null or throw an exception.
            </summary>
            <param name="function">The function to execute</param>
            <param name="err">The rpc error</param>
            <param name="withData">Append extra base exception message</param>
            <typeparam name="T">The return type</typeparam>
            <returns>The execution result</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">The Rpc exception</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.Result.NotNull_Or``1(``0,Neo.Plugins.RpcServer.RpcError)">
            <summary>
            Checks the execution result and throws an exception if it is null.
            </summary>
            <param name="result">The execution result</param>
            <param name="err">The rpc error</param>
            <typeparam name="T">The return type</typeparam>
            <returns>The execution result</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">The Rpc exception</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.Result.True_Or(System.Func{System.Boolean},Neo.Plugins.RpcServer.RpcError)">
            <summary>
            The execution result is true or throws an exception or null.
            </summary>
            <param name="function">The function to execute</param>
            <param name="err">the rpc exception code</param>
            <returns>the execution result</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">The rpc exception</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.Result.True_Or(System.Boolean,Neo.Plugins.RpcServer.RpcError)">
            <summary>
            Checks if the execution result is true or throws an exception.
            </summary>
            <param name="result">the execution result</param>
            <param name="err">the rpc exception code</param>
            <returns>the execution result</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">The rpc exception</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.Result.False_Or(System.Boolean,Neo.Plugins.RpcServer.RpcError)">
            <summary>
            Checks if the execution result is false or throws an exception.
            </summary>
            <param name="result">the execution result</param>
            <param name="err">the rpc exception code</param>
            <returns>the execution result</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">The rpc exception</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.Result.Null_Or``1(``0,Neo.Plugins.RpcServer.RpcError)">
            <summary>
            Check if the execution result is null or throws an exception.
            </summary>
            <param name="result">The execution result</param>
            <param name="err">the rpc error</param>
            <typeparam name="T">The execution result type</typeparam>
            <returns>The execution result</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">the rpc exception</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcErrorFactory.AlreadyExists(System.String)">
            <summary>
            The resource already exists. For example, the transaction is already confirmed, can't be cancelled.
            </summary>
            <param name="data">The data of the error.</param>
            <returns>The RpcError.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcErrorFactory.InvalidParams(System.String)">
            <summary>
            The request parameters are invalid. For example, the block hash or index is invalid.
            </summary>
            <param name="data">The data of the error.</param>
            <returns>The RpcError.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcErrorFactory.BadRequest(System.String)">
            <summary>
            The request is invalid. For example, the request body is invalid.
            </summary>
            <param name="data">The data of the error.</param>
            <returns>The RpcError.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcErrorFactory.InvalidContractVerification(Neo.UInt160,System.Int32)">
            <summary>
            The contract verification function is invalid.
            For example, the contract doesn't have a verify method with the correct number of input parameters.
            </summary>
            <param name="contractHash">The hash of the contract.</param>
            <param name="pcount">The number of input parameters.</param>
            <returns>The RpcError.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcErrorFactory.InvalidContractVerification(System.String)">
            <summary>
            The contract function to verification is invalid.
            For example, the contract doesn't have a verify method with the correct number of input parameters.
            </summary>
            <param name="data">The data of the error.</param>
            <returns>The RpcError.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcErrorFactory.InvalidSignature(System.String)">
            <summary>
            The signature is invalid.
            </summary>
            <param name="data">The data of the error.</param>
            <returns>The RpcError.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcErrorFactory.OracleNotDesignatedNode(Neo.Cryptography.ECC.ECPoint)">
            <summary>
            The oracle is not a designated node.
            </summary>
            <param name="oraclePub">The public key of the oracle.</param>
            <returns>The RpcError.</returns>
        </member>
        <member name="T:Neo.Plugins.RpcServer.RpcMethodAttribute">
            <summary>
            Indicates that the method is an RPC method.
            Parameter type can be JArray, and if the parameter is a JArray,
            the method will be called with raw parameters from jsonrpc request.
            <para>
            Or one of the following types:
            </para>
            string, byte[], byte, sbyte, short, ushort, int, uint, long, ulong, double, bool,
            Guid, UInt160, UInt256, ContractNameOrHashOrId, BlockHashOrIndex, ContractParameter[],
            Address, SignersAndWitnesses
            <para>
            The return type can be one of JToken or Task&lt;JToken&gt;.
            </para>
            </summary>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetBestBlockHash">
            <summary>
            Gets the hash of the best (most recent) block.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "getbestblockhash"}</code>
            <para>Response format:</para>
            <code>
            {"jsonrpc": "2.0", "id": 1, "result": "The block hash(UInt256)"}
            </code>
            </summary>
            <returns>The hash of the best block as a <see cref="T:Neo.Json.JToken"/>.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetBlock(Neo.Plugins.RpcServer.Model.BlockHashOrIndex,System.Boolean)">
            <summary>
            Gets a block by its hash or index.
            <para>Request format:</para>
            <code>
            // Request with block hash(for example: 0x6c0b6c03fbc7d7d797ddd6483fe59a64f77c47475c1da600b71b189f6f4f234a)
            {"jsonrpc": "2.0", "id": 1, "method": "getblock", "params": ["The block hash(UInt256)"]}
            </code>
            <code>
            // Request with block index
            {"jsonrpc": "2.0", "id": 1, "method": "getblock", "params": [100]}
            </code>
            <code>
            // Request with block hash and verbose is true
            {"jsonrpc": "2.0", "id": 1, "method": "getblock", "params": ["The block hash(UInt256)", true]}
            </code>
            <para>Response format:</para>
            <code>
            {"jsonrpc": "2.0", "id": 1, "result": "A base64-encoded string of the block"}
            </code>
            <para>If verbose is true, the response format is:</para>
            <code>{
              "jsonrpc":"2.0",
              "id":1,
              "result":{
                "hash":"The block hash(UInt256)",
                "size":697, // The size of the block
                "version":0, // The version of the block
                "previousblockhash":"The previous block hash(UInt256)",
                "merkleroot":"The merkle root(UInt256)",
                "time":1627896461306, // The timestamp of the block
                "nonce":"09D4422954577BCE", // The nonce of the block
                "index":100, // The index of the block
                "primary":2, // The primary of the block
                "nextconsensus":"The Base58Check-encoded next consensus address",
                "witnesses":[{"invocation":"A base64-encoded string","verification":"A base64-encoded string"}],
                "tx":[], // The transactions of the block
                "confirmations": 200, // The confirmations of the block, if verbose is true
                "nextblockhash":"The next block hash(UInt256)" // The next block hash, if verbose is true
              }
            }</code>
            </summary>
            <param name="blockHashOrIndex">The block hash or index.</param>
            <param name="verbose">Optional, the default value is false.</param>
            <returns>The block data as a <see cref="T:Neo.Json.JToken"/>. If the second item of _params is true, then
            block data is json format, otherwise, the return type is Base64-encoded byte array.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetBlockHeaderCount">
            <summary>
            Gets the number of block headers in the blockchain.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "getblockheadercount"}</code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": 100 /* The number of block headers in the blockchain */}</code>
            </summary>
            <returns>The count of block headers as a <see cref="T:Neo.Json.JToken"/>.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetBlockCount">
            <summary>
            Gets the number of blocks in the blockchain.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "getblockcount"}</code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": 100 /* The number of blocks in the blockchain */}</code>
            </summary>
            <returns>The count of blocks as a <see cref="T:Neo.Json.JToken"/>.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetBlockHash(System.UInt32)">
            <summary>
            Gets the hash of the block at the specified height.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "getblockhash", "params": [100] /* The block index */}</code>
            <para>Response format:</para>
            <code>
            {"jsonrpc": "2.0", "id": 1, "result": "The block hash(UInt256)"}
            </code>
            </summary>
            <param name="height">Block index (block height)</param>
            <returns>The hash of the block at the specified height as a <see cref="T:Neo.Json.JToken"/>.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetBlockHeader(Neo.Plugins.RpcServer.Model.BlockHashOrIndex,System.Boolean)">
            <summary>
            Gets a block header by its hash or index.
            <param name="blockHashOrIndex">The block script hash or index (i.e. block height=number of blocks - 1).</param>
            <param name="verbose">Optional, the default value is false.</param>
            <remarks>
            When verbose is false, serialized information of the block is returned in a hexadecimal string.
            If you need the detailed information, use the SDK for deserialization.
            When verbose is true or 1, detailed information of the block is returned in Json format.
            </remarks>
            <para>Request format:</para>
            <code>
            // Request with block hash(for example: 0x6c0b6c03fbc7d7d797ddd6483fe59a64f77c47475c1da600b71b189f6f4f234a)
            {"jsonrpc": "2.0", "id": 1, "method": "getblockheader", "params": ["The block hash(UInt256)"]}
            </code>
            <code>
            // Request with block index
            {"jsonrpc": "2.0", "id": 1, "method": "getblockheader", "params": [100]}
            </code>
            <code>
            // Request with block index and verbose is true
            {"jsonrpc": "2.0", "id": 1, "method": "getblockheader", "params": [100, true]}
            </code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": "A base64-encoded string of the block header"}</code>
            <para>If verbose is true, the response format is:</para>
            <code>{
              "jsonrpc":"2.0",
              "id":1,
              "result": {
                "hash": "The block hash(UInt256)",
                "size": 696, // The size of the block header
                "version": 0, // The version of the block header
                "previousblockhash": "The previous block hash(UInt256)",
                "merkleroot": "The merkle root(UInt256)",
                "time": 1627896461306, // The timestamp of the block header
                "nonce": "09D4422954577BCE", // The nonce of the block header
                "index": 100, // The index of the block header
                "primary": 2, // The primary of the block header
                "nextconsensus": "The Base58Check-encoded next consensus address",
                "witnesses": [{"invocation":"A base64-encoded string", "verification":"A base64-encoded string"}],
                "confirmations": 200, // The confirmations of the block header, if verbose is true
                "nextblockhash": "The next block hash(UInt256)" // The next block hash, if verbose is true
              }
            }</code>
            </summary>
            <returns>
            The block header data as a <see cref="T:Neo.Json.JToken"/>.
            In json format if the second item of _params is true, otherwise Base64-encoded byte array.
            </returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetContractState(Neo.Plugins.RpcServer.Model.ContractNameOrHashOrId)">
            <summary>
            Gets the state of a contract by its ID or script hash or (only for native contracts) by case-insensitive name.
            <para>Request format:</para>
            <code>
            {"jsonrpc": "2.0", "id": 1, "method": "getcontractstate", "params": ["The contract id(int) or hash(UInt160)"]}
            </code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": "A json string of the contract state"}</code>
            </summary>
            <param name="contractNameOrHashOrId">Contract name or script hash or the native contract id.</param>
            <returns>The contract state in json format as a <see cref="T:Neo.Json.JToken"/>.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetRawMemPool(System.Boolean)">
            <summary>
            Gets the current memory pool transactions.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "getrawmempool", "params": [true/*shouldGetUnverified, optional*/]}</code>
            <para>Response format:</para>
            If shouldGetUnverified is true, the response format is:
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {
                "height": 100,
                "verified": ["The tx hash"], // The verified transactions
                "unverified": ["The tx hash"] // The unverified transactions
              }
            }</code>
            If shouldGetUnverified is false, the response format is:
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": ["The tx hash"] // The verified transactions
            }</code>
            </summary>
            <param name="shouldGetUnverified">Optional, the default value is false.</param>
            <returns>The memory pool transactions in json format as a <see cref="T:Neo.Json.JToken"/>.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetRawTransaction(Neo.UInt256,System.Boolean)">
            <summary>
            Gets a transaction by its hash.
            <para>Request format:</para>
            <code>
            {"jsonrpc": "2.0", "id": 1, "method": "getrawtransaction", "params": ["The tx hash", true/*verbose, optional*/]}
            </code>
            <para>Response format:</para>
            If verbose is false, the response format is:
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": "The Base64-encoded tx data"
            }</code>
            If verbose is true, the response format is:
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {
                "hash": "The tx hash(UInt256)",
                "size": 272, // The size of the tx
                "version": 0, // The version of the tx
                "nonce": 1553700339, // The nonce of the tx
                "sender": "The Base58Check-encoded sender address", // The sender address of the tx
                "sysfee": "100000000", // The system fee of the tx
                "netfee": "1272390", // The network fee of the tx
                "validuntilblock": 2105487, // The valid until block of the tx
                "attributes": [], // The attributes of the tx
                "signers": [], // The signers of the tx
                "script": "A Base64-encoded string", // The script of the tx
                "witnesses": [{"invocation": "A base64-encoded string", "verification": "A base64-encoded string"}] // The witnesses of the tx
                "confirmations": 100, // The confirmations of the tx
                "blockhash": "The block hash", // The block hash
                "blocktime": 1627896461306 // The block time
              }
            }</code>
            </summary>
            <param name="hash">The transaction hash.</param>
            <param name="verbose">Optional, the default value is false.</param>
            <returns>The transaction data as a <see cref="T:Neo.Json.JToken"/>. In json format if verbose is true, otherwise base64string. </returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetStorage(Neo.Plugins.RpcServer.Model.ContractNameOrHashOrId,System.String)">
            <summary>
            Gets the storage item by contract ID or script hash and key.
            <para>Request format:</para>
            <code>
            {
              "jsonrpc": "2.0",
              "id": 1,
              "method": "getstorage",
              "params": ["The contract id(int),  hash(UInt160) or native contract name(string)", "The Base64-encoded key"]
            }
            </code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": "The Base64-encoded storage value"}</code>
            </summary>
            <param name="contractNameOrHashOrId">The contract ID or script hash.</param>
            <param name="base64Key">The Base64-encoded storage key.</param>
            <returns>The storage item as a <see cref="T:Neo.Json.JToken"/>.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.FindStorage(Neo.Plugins.RpcServer.Model.ContractNameOrHashOrId,System.String,System.Int32)">
            <summary>
            Finds storage items by contract ID or script hash and prefix.
            <para>Request format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "method": "findstorage",
              "params": ["
                "The contract id(int), hash(UInt160) or native contract name(string)",
                "The base64-encoded key prefix",
                0 /*The start index, optional*/
              ]
            }</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {
                "truncated": true,
                "next": 100,
                "results": [
                  {"key": "The Base64-encoded storage key", "value": "The Base64-encoded storage value"},
                  {"key": "The Base64-encoded storage key", "value": "The Base64-encoded storage value"},
                  // ...
                ]
              }
            }</code>
            </summary>
            <param name="contractNameOrHashOrId">The contract ID (int) or script hash (UInt160).</param>
            <param name="base64KeyPrefix">The Base64-encoded storage key prefix.</param>
            <param name="start">The start index.</param>
            <returns>The found storage items <see cref="T:Neo.SmartContract.StorageItem"/> as a <see cref="T:Neo.Json.JToken"/>.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetTransactionHeight(Neo.UInt256)">
            <summary>
            Gets the height of a transaction by its hash.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "gettransactionheight", "params": ["The tx hash(UInt256)"]}</code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": 100}</code>
            </summary>
            <param name="hash">The transaction hash.</param>
            <returns>The height of the transaction as a <see cref="T:Neo.Json.JToken"/>.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetNextBlockValidators">
            <summary>
            Gets the next block validators.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "getnextblockvalidators"}</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": [
                {"publickey": "The public key", "votes": 100 /* The votes of the validator */}
                // ...
              ]
            }</code>
            </summary>
            <returns>The next block validators as a <see cref="T:Neo.Json.JToken"/>.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetCandidates">
            <summary>
            Gets the list of candidates for the next block validators.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "getcandidates"}</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": [
                {"publickey": "The public key", "votes": "An integer number in string", "active": true /* Is active or not */}
                // ...
              ]
            }</code>
            </summary>
            <returns>The candidates public key list as a JToken.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetCommittee">
            <summary>
            Gets the list of committee members.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "getcommittee"}</code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": ["The public key"]}</code>
            </summary>
            <returns>The committee members publickeys as a <see cref="T:Neo.Json.JToken"/>.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetNativeContracts">
            <summary>
            Gets the list of native contracts.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "getnativecontracts"}</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": [{
                 "id": -1, // The contract id
                 "updatecounter": 0, // The update counter
                 "hash": "The contract hash(UInt160)", // The contract hash
                 "nef":  {
                   "magic": 0x3346454E, // The magic number, always 0x3346454E at present.
                   "compiler": "The compiler name",
                   "source": "The url of the source file",
                   "tokens": [
                     {
                       "hash": "The token hash(UInt160)",
                       "method": "The token method name",
                       "paramcount": 0, // The number of parameters
                       "hasreturnvalue": false, // Whether the method has a return value
                       "callflags": 0 // see CallFlags
                     } // A token in the contract
                     // ...
                   ],
                   "script": "The Base64-encoded script", // The Base64-encoded script
                   "checksum": 0x12345678 // The checksum
                 },
                 "manifest": {
                   "name": "The contract name",
                   "groups": [
                     {"pubkey": "The public key", "signature": "The signature"} // A group in the manifest
                   ],
                   "features": {}, // The features that the contract supports
                   "supportedstandards": ["The standard name"], // The standards that the contract supports
                   "abi": {
                     "methods": [
                       {
                         "name": "The method name",
                         "parameters": [
                           {"name": "The parameter name", "type": "The parameter type"} // A parameter in the method
                           // ...
                         ],
                         "returntype": "The return type",
                         "offset": 0, // The offset in script of the method
                         "safe": false // Whether the method is safe
                       } // A method in the abi
                       // ...
                     ],
                     "events": [
                       {
                         "name": "The event name",
                         "parameters": [
                           {"name": "The parameter name", "type": "The parameter type"} // A parameter in the event
                           // ...
                         ]
                       } // An event in the abi
                       // ...
                     ]
                   }, // The abi of the contract
                   "permissions": [
                     {
                       "contract": "The contract hash(UInt160), group(ECPoint), or '*'", // '*' means all contracts
                       "methods": ["The method name or '*'"] // '*' means all methods
                     } // A permission in the contract
                     // ...
                   ], // The permissions of the contract
                   "trusts": [
                     {
                       "contract": "The contract hash(UInt160), group(ECPoint), or '*'", // '*' means all contracts
                       "methods": ["The method name or '*'"] // '*' means all methods
                     } // A trust in the contract
                     // ...
                   ], // The trusts of the contract
                   "extra": {} // A json object, the extra content of the contract
                 } // The manifest of the contract
               }]
            }</code>
            </summary>
            <returns>The native contract states <see cref="T:Neo.SmartContract.ContractState"/> as a <see cref="T:Neo.Json.JToken"/>.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.UnwrapException(System.Exception)">
            <summary>
            Unwraps an exception to get the original exception.
            This is particularly useful for TargetInvocationException and AggregateException which wrap the actual exception.
            </summary>
            <param name="ex">The exception to unwrap</param>
            <returns>The unwrapped exception</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetConnectionCount">
            <summary>
            Gets the current number of connections to the node.
            <para>Request format:</para>
            <code>{ "jsonrpc": "2.0", "id": 1,"method": "getconnectioncount"}
            </code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": 10}</code>
            </summary>
            <returns>The number of connections as a JToken.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetPeers">
            <summary>
            Gets information about the peers connected to the node.
            <para>Request format:</para>
            <code>{ "jsonrpc": "2.0", "id": 1,"method": "getpeers"}
            </code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {
                "unconnected": [{"address": "The address", "port": "The port"}],
                "bad": [],
                "connected": [{"address": "The address", "port": "The port"}]
              }
            }</code>
            </summary>
            <returns>A JObject containing information about unconnected, bad, and connected peers.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetRelayResult(Neo.Ledger.VerifyResult,Neo.UInt256)">
            <summary>
            Processes the result of a transaction or block relay and returns appropriate response or throws an exception.
            </summary>
            <param name="reason">The verification result of the relay.</param>
            <param name="hash">The hash of the transaction or block.</param>
            <returns>A JObject containing the hash if successful, otherwise throws an RpcException.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetVersion">
            <summary>
            Gets version information about the node, including network, protocol, and RPC settings.
            <para>Request format:</para>
            <code>{ "jsonrpc": "2.0", "id": 1,"method": "getversion"}
            </code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {
                "tcpport": 10333, // The TCP port,
                "nonce": 1, // The nonce,
                "useragent": "The user agent",
                "rpc": {
                  "maxiteratorresultitems": 100, // The maximum number of items in the iterator result,
                  "sessionenabled": false // Whether session is enabled,
                 },
                 "protocol": {
                  "addressversion": 0x35, // The address version,
                  "network": 5195086, // The network,
                  "validatorscount": 0, // The number of validators,
                  "msperblock": 15000, // The time per block in milliseconds,
                  "maxtraceableblocks": 2102400, // The maximum traceable blocks,
                  "maxvaliduntilblockincrement": 86400000 / 15000, // The maximum valid until block increment,
                  "maxtransactionsperblock": 512, // The maximum number of transactions per block,
                  "memorypoolmaxtransactions": 50000, // The maximum number of transactions in the memory pool,
                  "initialgasdistribution": 5200000000000000, // The initial gas distribution,
                  "hardforks": [{"name": "The hardfork name", "blockheight": 0/*The block height*/ }],
                  "standbycommittee": ["The public key"],
                  "seedlist": ["The seed list"]
                }
              }
            }</code>
            </summary>
            <returns>A JObject containing detailed version and configuration information.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.StripPrefix(System.String,System.String)">
            <summary>
            Removes a specified prefix from a string if it exists.
            </summary>
            <param name="s">The input string.</param>
            <param name="prefix">The prefix to remove.</param>
            <returns>The string with the prefix removed if it existed, otherwise the original string.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.SendRawTransaction(System.String)">
            <summary>
            Sends a raw transaction to the network.
            <para>Request format:</para>
            <code>
            {"jsonrpc": "2.0", "id": 1,"method": "sendrawtransaction", "params": ["A Base64-encoded transaction"]}
            </code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": {"hash": "The hash of the transaction(UInt256)"}}</code>
            </summary>
            <param name="base64Tx">The base64-encoded transaction.</param>
            <returns>A JToken containing the result of the transaction relay.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.SubmitBlock(System.String)">
            <summary>
            Submits a new block to the network.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1,"method": "submitblock", "params": ["A Base64-encoded block"]}
            </code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": {"hash": "The hash of the block(UInt256)"}}</code>
            </summary>
            <param name="base64Block">The base64-encoded block.</param>
            <returns>A JToken containing the result of the block submission.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.InvokeFunction(Neo.UInt160,System.String,Neo.SmartContract.ContractParameter[],Neo.Plugins.RpcServer.Model.SignersAndWitnesses,System.Boolean)">
            <summary>
            Invokes a function on a contract.
            <para>Request format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "method": "invokefunction",
              "params": [
                "An UInt160 ScriptHash",  // the contract address
                "operation",  // the operation to invoke
                [{"type": "ContractParameterType", "value": "The parameter value"}],  // ContractParameter, the arguments
                [{
                  // The part of the Signer
                  "account": "An UInt160 or Base58Check address", // The account of the signer, required
                  "scopes": "WitnessScope", // WitnessScope, required
                  "allowedcontracts": ["The contract hash(UInt160)"], // optional
                  "allowedgroups": ["PublicKey"], // ECPoint, i.e. ECC PublicKey, optional
                  "rules": [{"action": "WitnessRuleAction", "condition": {/*A json of WitnessCondition*/}}] // WitnessRule
                  // The part of the Witness, optional
                  "invocation": "A Base64-encoded string",
                  "verification": "A Base64-encoded string"
                }], // A JSON array of signers and witnesses, optional
                false // useDiagnostic, a bool value indicating whether to use diagnostic information, optional
              ]
            }</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {
                "script": "A Base64-encoded string",
                "state": "A string of VMState",
                "gasconsumed": "An integer number in string",
                "exception": "The exception message",
                "stack": [{"type": "The stack item type", "value": "The stack item value"}],
                "notifications": [
                  {"eventname": "The event name", "contract": "The contract hash", "state": {"interface": "A string", "id": "The GUID string"}}
                ], // The notifications, optional
                "diagnostics": {
                  "invokedcontracts": {"hash": "The contract hash","call": [{"hash": "The contract hash"}]}, // The invoked contracts
                  "storagechanges": [
                    {
                      "state": "The TrackState string",
                      "key": "The Base64-encoded key",
                      "value": "The Base64-encoded value"
                    }
                    // ...
                  ] // The storage changes
                }, // The diagnostics, optional, if useDiagnostic is true
                "session": "A GUID string" // The session id, optional
              }
            }</code>
            </summary>
            <param name="scriptHash">The script hash of the contract to invoke.</param>
            <param name="operation">The operation to invoke.</param>
            <param name="args">The arguments to pass to the function.</param>
            <param name="signersAndWitnesses">The signers and witnesses of the transaction.</param>
            <param name="useDiagnostic">A boolean value indicating whether to use diagnostic information.</param>
            <returns>The result of the function invocation.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">
            Thrown when the script hash is invalid, the contract is not found, or the verification fails.
            </exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.InvokeScript(System.Byte[],Neo.Plugins.RpcServer.Model.SignersAndWitnesses,System.Boolean)">
            <summary>
            Invokes a script.
            <para>Request format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "method": "invokescript",
              "params": [
                "A Base64-encoded script", // the script to invoke
                [{
                  // The part of the Signer
                  "account": "An UInt160 or Base58Check address", // The account of the signer, required
                  "scopes": "WitnessScope", // WitnessScope, required
                  "allowedcontracts": ["The contract hash(UInt160)"], // optional
                  "allowedgroups": ["PublicKey"], // ECPoint, i.e. ECC PublicKey, optional
                  "rules": [{"action": "WitnessRuleAction", "condition": {/* A json of WitnessCondition */ }}], // WitnessRule
                  // The part of the Witness, optional
                  "invocation": "A Base64-encoded string",
                  "verification": "A Base64-encoded string"
                }], // A JSON array of signers and witnesses, optional
                false // useDiagnostic, a bool value indicating whether to use diagnostic information, optional
              ]
            }</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {
                "script": "A Base64-encoded script",
                "state": "A string of VMState", // see VMState
                "gasconsumed": "An integer number in string", // The gas consumed
                "exception": "The exception message", // The exception message
                "stack": [
                  {"type": "The stack item type", "value": "The stack item value"} // A stack item in the stack
                  // ...
                ],
                "notifications": [
                  {"eventname": "The event name", // The name of the event
                   "contract": "The contract hash", // The hash of the contract
                   "state": {"interface": "A string", "id": "The GUID string"} // The state of the event
                  }
                ], // The notifications, optional
                "diagnostics": {
                  "invokedcontracts": {"hash": "The contract hash","call": [{"hash": "The contract hash"}]}, // The invoked contracts
                  "storagechanges": [
                    {
                      "state": "The TrackState string",
                      "key": "The Base64-encoded key",
                      "value": "The Base64-encoded value"
                    }
                    // ...
                  ] // The storage changes
                }, // The diagnostics, optional, if useDiagnostic is true
                "session": "A GUID string" // The session id, optional
              }
            }</code>
            </summary>
            <param name="script">The script to invoke.</param>
            <param name="signersAndWitnesses">The signers and witnesses of the transaction.</param>
            <param name="useDiagnostic">A boolean value indicating whether to use diagnostic information.</param>
            <returns>The result of the script invocation.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">
            Thrown when the script is invalid, the verification fails, or the script hash is invalid.
            </exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.TraverseIterator(System.Guid,System.Guid,System.Int32)">
            <summary>
            <para>Request format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "method": "traverseiterator",
              "params": [
                "A GUID string(The session id)",
                "A GUID string(The iterator id)",
                100, // An integer number(The number of items to traverse)
              ]
            }</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": [{"type": "The stack item type", "value": "The stack item value"}]
            }</code>
            </summary>
            <param name="sessionId">The session id.</param>
            <param name="iteratorId">The iterator id.</param>
            <param name="count">The number of items to traverse.</param>
            <returns></returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.TerminateSession(System.Guid)">
            <summary>
            Terminates a session.
            <para>Request format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "method": "terminatesession",
              "params": ["A GUID string(The session id)"]
            }</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": true // true if the session is terminated successfully, otherwise false
            }</code>
            </summary>
            <param name="sessionId">The session id.</param>
            <returns>True if the session is terminated successfully, otherwise false.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">Thrown when the session id is invalid.</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetUnclaimedGas(Neo.Plugins.RpcServer.Model.Address)">
            <summary>
            Gets the unclaimed gas of an address.
            <para>Request format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "method": "getunclaimedgas",
              "params": ["An UInt160 or Base58Check address"]
            }</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {"unclaimed": "An integer in string", "address": "The Base58Check address"}
            }</code>
            </summary>
            <param name="address">The address as a UInt160 or Base58Check address.</param>
            <returns>A JSON object containing the unclaimed gas and the address.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">
            Thrown when the address is invalid.
            </exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.ListPlugins">
            <summary>
            Lists all plugins.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "listplugins"}</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": [
                {"name": "The plugin name", "version": "The plugin version", "interfaces": ["The plugin method name"]}
              ]
            }</code>
            </summary>
            <returns>A JSON array containing the plugin information.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.ValidateAddress(System.String)">
            <summary>
            Validates an address.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "validateaddress", "params": ["The Base58Check address"]}</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {"address": "The Base58Check address", "isvalid": true}
            }</code>
            </summary>
            <param name="address">The address as a string.</param>
            <returns>A JSON object containing the address and whether it is valid.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.CheckWallet">
            <summary>
            Checks if a wallet is open and throws an error if not.
            </summary>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.CloseWallet">
            <summary>
            Closes the currently opened wallet.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "closewallet", "params": []}</code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": true}</code>
            </summary>
            <returns>Returns true if the wallet was successfully closed.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.DumpPrivKey(Neo.Plugins.RpcServer.Model.Address)">
            <summary>
            Exports the private key of a specified address.
            <para>Request format:</para>
            <code>
            {"jsonrpc": "2.0", "id": 1, "method": "dumpprivkey", "params": ["An UInt160 or Base58Check address"]}
            </code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": "A WIF-encoded private key as a string"}</code>
            </summary>
            <param name="address">The address(UInt160 or Base58Check address) to export the private key for.</param>
            <returns>The exported private key as a string.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">Thrown when no wallet is open or the address is invalid.</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetNewAddress">
            <summary>
            Creates a new address in the wallet.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "getnewaddress", "params": []}</code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": "The newly created Base58Check address"}</code>
            </summary>
            <returns>The newly created address as a string.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">Thrown when no wallet is open.</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetWalletBalance(Neo.UInt160)">
            <summary>
            Gets the balance of a specified asset in the wallet.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "getwalletbalance", "params": ["An UInt160 address"]}</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {"balance": "0"} // An integer number in string, the balance of the specified asset in the wallet
            }</code>
            </summary>
            <param name="assetId">An 1-element(UInt160) array containing the asset ID as a string.</param>
            <returns>A JSON object containing the balance of the specified asset.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">Thrown when no wallet is open or the asset ID is invalid.</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetWalletUnclaimedGas">
            <summary>
            Gets the amount of unclaimed GAS in the wallet.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "getwalletunclaimedgas", "params": []}</code>
            <para>Response format:</para>
            <code>
            {"jsonrpc": "2.0", "id": 1, "result": "The amount of unclaimed GAS(an integer number in string)"}
            </code>
            </summary>
            <returns>The amount of unclaimed GAS(an integer number in string).</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">Thrown when no wallet is open.</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.ImportPrivKey(System.String)">
            <summary>
            Imports a private key into the wallet.
            <para>Request format:</para>
            <code>
            {"jsonrpc": "2.0", "id": 1, "method": "importprivkey", "params": ["A WIF-encoded private key"]}
            </code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {"address": "The Base58Check address", "haskey": true, "label": "The label", "watchonly": false}
            }</code>
            </summary>
            <param name="privkey">The WIF-encoded private key to import.</param>
            <returns>A JSON object containing information about the imported account.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">Thrown when no wallet is open or the private key is invalid.</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.CalculateNetworkFee(System.Byte[])">
            <summary>
            Calculates the network fee for a given transaction.
            <para>Request format:</para>
            <code>
            {"jsonrpc": "2.0", "id": 1, "method": "calculatenetworkfee", "params": ["A Base64-encoded transaction"]}
            </code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": {"networkfee": "The network fee(an integer number in string)"}}</code>
            </summary>
            <param name="tx">The raw transaction to calculate the network fee for.</param>
            <returns>A JSON object containing the calculated network fee.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">Thrown when the input parameters are invalid or the transaction is malformed.</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.ListAddress">
            <summary>
            Lists all addresses in the wallet.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "listaddress", "params": []}</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": [{"address": "address", "haskey": true, "label": "label", "watchonly": false} ]
            }</code>
            </summary>
            <returns>An array of JSON objects, each containing information about an address in the wallet.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">Thrown when no wallet is open.</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.OpenWallet(System.String,System.String)">
            <summary>
            Opens a wallet file.
            <para>Request format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "method": "openwallet", "params": ["path", "password"]}</code>
            <para>Response format:</para>
            <code>{"jsonrpc": "2.0", "id": 1, "result": true}</code>
            </summary>
            <param name="path">The path to the wallet file.</param>
            <param name="password">The password to open the wallet.</param>
            <returns>Returns true if the wallet was successfully opened.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">
            Thrown when the wallet file is not found, the wallet is not supported, or the password is invalid.
            </exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.ProcessInvokeWithWallet(Neo.Json.JObject,System.Byte[],Neo.Network.P2P.Payloads.Signer[])">
            <summary>
            Processes the result of an invocation with wallet for signing.
            </summary>
            <param name="result">The result object to process.</param>
            <param name="script">The script to process.</param>
            <param name="signers">Optional signers for the transaction.</param>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.SendFrom(Neo.UInt160,Neo.Plugins.RpcServer.Model.Address,Neo.Plugins.RpcServer.Model.Address,System.String,Neo.Plugins.RpcServer.Model.Address[])">
            <summary>
            Transfers an asset from a specific address to another address.
            <para>Request format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "method": "sendfrom",
              "params": [
                "An UInt160 assetId",
                "An UInt160 from address",
                "An UInt160 to address",
                "An amount as a string(An integer/decimal number in string)",
                ["UInt160 or Base58Check address"] // signers is optional
              ]
            }</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {
                "hash": "The tx hash(UInt256)", // The hash of the transaction
                "size": 272, // The size of the tx
                "version": 0, // The version of the tx
                "nonce": 1553700339, // The nonce of the tx
                "sender": "The Base58Check address", // The sender of the tx
                "sysfee": "100000000", // The system fee of the tx
                "netfee": "1272390", // The network fee of the tx
                "validuntilblock": 2105487, // The valid until block of the tx
                "attributes": [], // The attributes of the tx
                "signers": [{"account": "The UInt160 address", "scopes": "CalledByEntry"}], // The signers of the tx
                "script": "A Base64-encoded script",
                "witnesses": [{"invocation": "A Base64-encoded string", "verification": "A Base64-encoded string"}] // The witnesses of the tx
              }
            }</code>
            </summary>
            <param name="assetId">The asset ID as a string.</param>
            <param name="from">The from address as a string.</param>
            <param name="to">The to address as a string.</param>
            <param name="amount">The amount as a string.</param>
            <param name="signers">An array of signers, each containing: The address of the signer as a string.</param>
            <returns>The transaction details if successful, or the contract parameters if signatures are incomplete.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">Thrown when no wallet is open, parameters are invalid, or there are insufficient funds.</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.SendMany(Neo.Json.JArray)">
            <summary>
            Transfers assets to multiple addresses.
            <para>Request format:</para>
            <code>{
             "jsonrpc": "2.0",
             "id": 1,
             "method": "sendmany",
             "params": [
                "An UInt160 address",  // "from", optional
                [{"asset": "An UInt160 assetId", "value": "An integer/decimal as a string", "address": "An UInt160 address"}],
                ["UInt160 or Base58Check address"] // signers, optional
              ]
            }</code>
            <para>Response format:</para>
            <code> {
             "jsonrpc": "2.0", 
             "id": 1, 
              "result": {
                "hash": "The tx hash(UInt256)", // The hash of the transaction
                "size": 483, // The size of the tx
                "version": 0, // The version of the tx
                "nonce": 34429660, // The nonce of the tx
                "sender": "The Base58Check address", // The sender of the tx
                "sysfee": "100000000", // The system fee of the tx
                "netfee": "2483780", // The network fee of the tx
                "validuntilblock": 2105494, // The valid until block of the tx
                "attributes": [], // The attributes of the tx
                "signers": [{"account": "The UInt160 address", "scopes": "CalledByEntry"}], // The signers of the tx
                "script": "A Base64-encoded script",
                "witnesses": [{"invocation": "A Base64-encoded string", "verification": "A Base64-encoded string" }] // The witnesses of the tx
              }
            }</code>
            </summary>
            <param name="_params">
            An array containing the following elements:
            [0] (optional): The address to send from as a string. If omitted, the assets will be sent from any address in the wallet.
            [1]: An array of transfer objects, each containing:
                - "asset": The asset ID (UInt160) as a string.
                - "value": The amount to transfer as a string.
                - "address": The recipient address as a string.
            [2] (optional): An array of signers, each containing:
                - The address of the signer as a string.
            </param>
            <returns>
            If the transaction is successfully created and all signatures are present:
                Returns a JSON object representing the transaction.
            If not all signatures are present:
                Returns a JSON object representing the contract parameters that need to be signed.
            </returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">
            Thrown when:
            - No wallet is open.
            - The 'to' parameter is invalid or empty.
            - Any of the asset IDs are invalid.
            - Any of the amounts are negative or invalid.
            - Any of the addresses are invalid.
            - There are insufficient funds for the transfer.
            - The network fee exceeds the maximum allowed fee.
            </exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.SendToAddress(Neo.UInt160,Neo.Plugins.RpcServer.Model.Address,System.String)">
            <summary>
            Transfers an asset to a specific address.
            <para>Request format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "method": "sendtoaddress",
              "params": ["An UInt160 assetId", "An UInt160 address(to)", "An amount as a string(An integer/decimal number)"]
            }</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {
                "hash": "The tx hash(UInt256)", // The hash of the transaction
                "size": 483, // The size of the tx
                "version": 0, // The version of the tx
                "nonce": 34429660, // The nonce of the tx
                "sender": "The Base58Check address", // The sender of the tx
                "sysfee": "100000000", // The system fee of the tx
                "netfee": "2483780", // The network fee of the tx
                "validuntilblock": 2105494, // The valid until block of the tx
                "attributes": [], // The attributes of the tx
                "signers": [{"account": "The UInt160 address", "scopes": "CalledByEntry"}], // The signers of the tx
                "script": "A Base64-encoded script",
                "witnesses": [{"invocation": "A Base64-encoded string", "verification": "A Base64-encoded string"}] // The witnesses of the tx
              }
            }</code>
            </summary>
            <param name="assetId">The asset ID as a string.</param>
            <param name="to">The to address as a string.</param>
            <param name="amount">The amount as a string.</param>
            <returns>The transaction details if successful, or the contract parameters if signatures are incomplete.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">Thrown when no wallet is open, parameters are invalid, or there are insufficient funds.</exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.CancelTransaction(Neo.UInt256,Neo.Plugins.RpcServer.Model.Address[],System.String)">
            <summary>
            Cancels an unconfirmed transaction.
            <para>Request format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "method": "canceltransaction",
              "params": [
               "An tx hash(UInt256)",
                ["UInt160 or Base58Check address"], // signers, optional
                "An amount as a string(An integer/decimal number)" // extraFee, optional
               ]
            }</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {
                "hash": "The tx hash(UInt256)", // The hash of the transaction
                "size": 483, // The size of the tx
                "version": 0, // The version of the tx
                "nonce": 34429660, // The nonce of the tx
                "sender": "The Base58Check address", // The sender of the tx
                "sysfee": "100000000", // A integer number in string
                "netfee": "2483780", // A integer number in string
                "validuntilblock": 2105494, // The valid until block of the tx
                "attributes": [], // The attributes of the tx
                "signers": [{"account": "The UInt160 address", "scopes": "CalledByEntry"}], // The signers of the tx
                "script": "A Base64-encoded script",
                "witnesses": [{"invocation": "A Base64-encoded string", "verification": "A Base64-encoded string"}] // The witnesses of the tx
              }
            }</code>
            </summary>
            <param name="txid">The transaction ID to cancel as a string.</param>
            <param name="signers">The signers as an array of strings.</param>
            <param name="extraFee">The extra fee as a string.</param>
            <returns>The details of the cancellation transaction.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">
            Thrown when no wallet is open, the transaction is already confirmed, or there are insufficient funds for the cancellation fee.
            </exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.InvokeContractVerify(Neo.UInt160,Neo.SmartContract.ContractParameter[],Neo.Plugins.RpcServer.Model.SignersAndWitnesses)">
            <summary>
            Invokes the verify method of a contract.
            <para>Request format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "method": "invokecontractverify",
              "params": [
                "The script hash(UInt160)",
                [
                 { "type": "The type of the parameter", "value": "The value of the parameter" }
                 // ...
                ], // The arguments as an array of ContractParameter JSON objects
                [{
                  // The part of the Signer
                  "account": "An UInt160 or Base58Check address", // The account of the signer, required
                  "scopes": "WitnessScope", // WitnessScope, required
                  "allowedcontracts": ["UInt160 address"], // optional
                  "allowedgroups": ["PublicKey"], // ECPoint, i.e. ECC PublicKey, optional
                  "rules": [{"action": "WitnessRuleAction", "condition": {/*A json of WitnessCondition*/}}], // WitnessRule
                   // The part of the Witness, optional
                  "invocation": "A Base64-encoded string",
                  "verification": "A Base64-encoded string"
                }], // A JSON array of signers and witnesses, optional
              ]
            }</code>
            <para>Response format:</para>
            <code>{
              "jsonrpc": "2.0",
              "id": 1,
              "result": {
                "script": "A Base64-encoded string",
                "state": "A string of VMState",
                "gasconsumed": "An integer number in string",
                "exception": "The exception message",
                "stack": [{"type": "The stack item type", "value": "The stack item value"}]
              }
            }</code>
            </summary>
            <param name="scriptHash">The script hash as a string.</param>
            <param name="args">The arguments as an array of strings.</param>
            <param name="signersAndWitnesses">The JSON array of signers and witnesses<see cref="M:Neo.Plugins.RpcServer.ParameterConverter.ToSignersAndWitnesses(Neo.Json.JToken,System.Byte)"/>. Optional.</param>
            <returns>A JSON object containing the result of the verification.</returns>
            <exception cref="T:Neo.Plugins.RpcServer.RpcException">
            Thrown when the script hash is invalid, the contract is not found, or the verification fails.
            </exception>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.GetVerificationResult(Neo.UInt160,Neo.SmartContract.ContractParameter[],Neo.Network.P2P.Payloads.Signer[],Neo.Network.P2P.Payloads.Witness[])">
            <summary>
            Gets the result of the contract verification.
            </summary>
            <param name="scriptHash">The script hash of the contract.</param>
            <param name="args">The contract parameters.</param>
            <param name="signers">Optional signers for the verification.</param>
            <param name="witnesses">Optional witnesses for the verification.</param>
            <returns>A JSON object containing the verification result.</returns>
        </member>
        <member name="M:Neo.Plugins.RpcServer.RpcServer.SignAndRelay(Neo.Persistence.DataCache,Neo.Network.P2P.Payloads.Transaction)">
            <summary>
            Signs and relays a transaction.
            </summary>
            <param name="snapshot">The data snapshot.</param>
            <param name="tx">The transaction to sign and relay.</param>
            <returns>A JSON object containing the transaction details.</returns>
        </member>
    </members>
</doc>
