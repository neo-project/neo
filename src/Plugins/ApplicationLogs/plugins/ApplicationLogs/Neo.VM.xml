<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Neo.VM</name>
    </assembly>
    <members>
        <member name="T:Neo.VM.BadScriptException">
            <summary>
            Represents the exception thrown when the bad script is parsed.
            </summary>
        </member>
        <member name="M:Neo.VM.BadScriptException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Neo.VM.BadScriptException"/> class.
            </summary>
        </member>
        <member name="M:Neo.VM.BadScriptException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Neo.VM.BadScriptException"/> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="T:Neo.VM.Cryptography.Murmur32">
            <summary>
            Computes the murmur hash for the input data.
            </summary>
        </member>
        <member name="M:Neo.VM.Cryptography.Murmur32.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:Neo.VM.Cryptography.Murmur32"/> class with the specified seed.
            </summary>
            <param name="seed">The seed to be used.</param>
        </member>
        <member name="T:Neo.VM.Debugger">
            <summary>
            A simple debugger for <see cref="T:Neo.VM.ExecutionEngine"/>.
            </summary>
        </member>
        <member name="M:Neo.VM.Debugger.#ctor(Neo.VM.ExecutionEngine)">
            <summary>
            Create a debugger on the specified <see cref="T:Neo.VM.ExecutionEngine"/>.
            </summary>
            <param name="engine">The <see cref="T:Neo.VM.ExecutionEngine"/> to attach the debugger.</param>
        </member>
        <member name="M:Neo.VM.Debugger.AddBreakPoint(Neo.VM.Script,System.UInt32)">
            <summary>
            Add a breakpoint at the specified position of the specified script. The VM will break the execution when it reaches the breakpoint.
            </summary>
            <param name="script">The script to add the breakpoint.</param>
            <param name="position">The position of the breakpoint in the script.</param>
        </member>
        <member name="M:Neo.VM.Debugger.Execute">
            <summary>
            Start or continue execution of the VM.
            </summary>
            <returns>Returns the state of the VM after the execution.</returns>
        </member>
        <member name="M:Neo.VM.Debugger.RemoveBreakPoint(Neo.VM.Script,System.UInt32)">
            <summary>
            Removes the breakpoint at the specified position in the specified script.
            </summary>
            <param name="script">The script to remove the breakpoint.</param>
            <param name="position">The position of the breakpoint in the script.</param>
            <returns>
            <see langword="true"/> if the breakpoint is successfully found and removed;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Neo.VM.Debugger.StepInto">
            <summary>
            Execute the next instruction. If the instruction involves a call to a method, it steps into the method and breaks the execution on the first instruction of that method.
            </summary>
            <returns>The VM state after the instruction is executed.</returns>
        </member>
        <member name="M:Neo.VM.Debugger.StepOut">
            <summary>
            Execute until the currently executed method is returned.
            </summary>
            <returns>The VM state after the currently executed method is returned.</returns>
        </member>
        <member name="M:Neo.VM.Debugger.StepOver">
            <summary>
            Execute the next instruction. If the instruction involves a call to a method, it does not step into the method (it steps over it instead).
            </summary>
            <returns>The VM state after the instruction is executed.</returns>
        </member>
        <member name="T:Neo.VM.EvaluationStack">
            <summary>
            Represents the evaluation stack in the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.EvaluationStack.Count">
            <summary>
            Gets the number of items on the stack.
            </summary>
        </member>
        <member name="M:Neo.VM.EvaluationStack.Peek(System.Int32)">
            <summary>
            Returns the item at the specified index from the top of the stack without removing it.
            </summary>
            <param name="index">The index of the object from the top of the stack.</param>
            <returns>The item at the specified index.</returns>
        </member>
        <member name="M:Neo.VM.EvaluationStack.Push(Neo.VM.Types.StackItem)">
            <summary>
            Pushes an item onto the top of the stack.
            </summary>
            <param name="item">The item to be pushed.</param>
        </member>
        <member name="M:Neo.VM.EvaluationStack.Pop">
            <summary>
            Removes and returns the item at the top of the stack.
            </summary>
            <returns>The item removed from the top of the stack.</returns>
        </member>
        <member name="M:Neo.VM.EvaluationStack.Pop``1">
            <summary>
            Removes and returns the item at the top of the stack and convert it to the specified type.
            </summary>
            <typeparam name="T">The type to convert to.</typeparam>
            <returns>The item removed from the top of the stack.</returns>
        </member>
        <member name="T:Neo.VM.ExceptionHandlingContext">
            <summary>
            Represents the context used for exception handling.
            </summary>
        </member>
        <member name="P:Neo.VM.ExceptionHandlingContext.CatchPointer">
            <summary>
            The position of the <see langword="catch"/> block.
            </summary>
        </member>
        <member name="P:Neo.VM.ExceptionHandlingContext.FinallyPointer">
            <summary>
            The position of the <see langword="finally"/> block.
            </summary>
        </member>
        <member name="P:Neo.VM.ExceptionHandlingContext.EndPointer">
            <summary>
            The end position of the <see langword="try"/>-<see langword="catch"/>-<see langword="finally"/> block.
            </summary>
        </member>
        <member name="P:Neo.VM.ExceptionHandlingContext.HasCatch">
            <summary>
            Indicates whether the <see langword="catch"/> block is included in the context.
            </summary>
        </member>
        <member name="P:Neo.VM.ExceptionHandlingContext.HasFinally">
            <summary>
            Indicates whether the <see langword="finally"/> block is included in the context.
            </summary>
        </member>
        <member name="P:Neo.VM.ExceptionHandlingContext.State">
            <summary>
            Indicates the state of the context.
            </summary>
        </member>
        <member name="T:Neo.VM.ExceptionHandlingState">
            <summary>
            Indicates the state of the <see cref="T:Neo.VM.ExceptionHandlingContext"/>.
            </summary>
        </member>
        <member name="F:Neo.VM.ExceptionHandlingState.Try">
            <summary>
            Indicates that the <see langword="try"/> block is being executed.
            </summary>
        </member>
        <member name="F:Neo.VM.ExceptionHandlingState.Catch">
            <summary>
            Indicates that the <see langword="catch"/> block is being executed.
            </summary>
        </member>
        <member name="F:Neo.VM.ExceptionHandlingState.Finally">
            <summary>
            Indicates that the <see langword="finally"/> block is being executed.
            </summary>
        </member>
        <member name="T:Neo.VM.ExecutionContext">
            <summary>
            Represents a frame in the VM execution stack.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionContext.RVCount">
            <summary>
            Indicates the number of values that the context should return when it is unloaded.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionContext.Script">
            <summary>
            The script to run in this context.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionContext.EvaluationStack">
            <summary>
            The evaluation stack for this context.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionContext.StaticFields">
            <summary>
            The slot used to store the static fields.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionContext.LocalVariables">
            <summary>
            The slot used to store the local variables of the current method.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionContext.Arguments">
            <summary>
            The slot used to store the arguments of the current method.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionContext.TryStack">
            <summary>
            The stack containing nested <see cref="T:Neo.VM.ExceptionHandlingContext"/>.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionContext.InstructionPointer">
            <summary>
            The pointer indicating the current instruction.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionContext.CurrentInstruction">
            <summary>
            Returns the current <see cref="T:Neo.VM.Instruction"/>.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionContext.NextInstruction">
            <summary>
            Returns the next <see cref="T:Neo.VM.Instruction"/>.
            </summary>
        </member>
        <member name="M:Neo.VM.ExecutionContext.Clone">
            <summary>
            Clones the context so that they share the same script, stack, and static fields.
            </summary>
            <returns>The cloned context.</returns>
        </member>
        <member name="M:Neo.VM.ExecutionContext.Clone(System.Int32)">
            <summary>
            Clones the context so that they share the same script, stack, and static fields.
            </summary>
            <param name="initialPosition">The instruction pointer of the new context.</param>
            <returns>The cloned context.</returns>
        </member>
        <member name="M:Neo.VM.ExecutionContext.GetState``1(System.Func{``0})">
            <summary>
            Gets custom data of the specified type. If the data does not exist, create a new one.
            </summary>
            <typeparam name="T">The type of data to be obtained.</typeparam>
            <param name="factory">A delegate used to create the entry. If factory is null, new() will be used.</param>
            <returns>The custom data of the specified type.</returns>
        </member>
        <member name="T:Neo.VM.ExecutionEngine">
            <summary>
            Represents the VM used to execute the script.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngine.Limits">
            <summary>
            Restrictions on the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngine.ReferenceCounter">
            <summary>
            Used for reference counting of objects in the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngine.InvocationStack">
            <summary>
            The invocation stack of the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngine.CurrentContext">
            <summary>
            The top frame of the invocation stack.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngine.EntryContext">
            <summary>
            The bottom frame of the invocation stack.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngine.ResultStack">
            <summary>
            The stack to store the return values.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngine.UncaughtException">
            <summary>
            The VM object representing the uncaught exception.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngine.State">
            <summary>
            The current state of the VM.
            </summary>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.#ctor(Neo.VM.JumpTable)">
            <summary>
            Initializes a new instance of the <see cref="T:Neo.VM.ExecutionEngine"/> class.
            </summary>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.#ctor(Neo.VM.JumpTable,Neo.VM.ReferenceCounter,Neo.VM.ExecutionEngineLimits)">
            <summary>
            Initializes a new instance of the <see cref="T:Neo.VM.ExecutionEngine"/> class with the specified <see cref="T:Neo.VM.ReferenceCounter"/> and <see cref="T:Neo.VM.ExecutionEngineLimits"/>.
            </summary>
            <param name="jumpTable">The jump table to be used.</param>
            <param name="referenceCounter">The reference counter to be used.</param>
            <param name="limits">Restrictions on the VM.</param>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.Execute">
            <summary>
            Start execution of the VM.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.ExecuteNext">
            <summary>
            Execute the next instruction.
            </summary>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.LoadContext(Neo.VM.ExecutionContext)">
            <summary>
            Loads the specified context into the invocation stack.
            </summary>
            <param name="context">The context to load.</param>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.UnloadContext(Neo.VM.ExecutionContext)">
            <summary>
            Called when a context is unloaded.
            </summary>
            <param name="context">The context being unloaded.</param>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.CreateContext(Neo.VM.Script,System.Int32,System.Int32)">
            <summary>
            Create a new context with the specified script without loading.
            </summary>
            <param name="script">The script used to create the context.</param>
            <param name="rvcount">The number of values that the context should return when it is unloaded.</param>
            <param name="initialPosition">The pointer indicating the current instruction.</param>
            <returns>The created context.</returns>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.LoadScript(Neo.VM.Script,System.Int32,System.Int32)">
            <summary>
            Create a new context with the specified script and load it.
            </summary>
            <param name="script">The script used to create the context.</param>
            <param name="rvcount">The number of values that the context should return when it is unloaded.</param>
            <param name="initialPosition">The pointer indicating the current instruction.</param>
            <returns>The created context.</returns>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.OnFault(System.Exception)">
            <summary>
            Called when an exception that cannot be caught by the VM is thrown.
            </summary>
            <param name="ex">The exception that caused the <see cref="F:Neo.VM.VMState.FAULT"/> state.</param>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.OnStateChanged">
            <summary>
            Called when the state of the VM changed.
            </summary>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.Peek(System.Int32)">
            <summary>
            Returns the item at the specified index from the top of the current stack without removing it.
            </summary>
            <param name="index">The index of the object from the top of the stack.</param>
            <returns>The item at the specified index.</returns>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.Pop">
            <summary>
            Removes and returns the item at the top of the current stack.
            </summary>
            <returns>The item removed from the top of the stack.</returns>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.Pop``1">
            <summary>
            Removes and returns the item at the top of the current stack and convert it to the specified type.
            </summary>
            <typeparam name="T">The type to convert to.</typeparam>
            <returns>The item removed from the top of the stack.</returns>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.PostExecuteInstruction(Neo.VM.Instruction)">
            <summary>
            Called after an instruction is executed.
            </summary>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.PreExecuteInstruction(Neo.VM.Instruction)">
            <summary>
            Called before an instruction is executed.
            </summary>
        </member>
        <member name="M:Neo.VM.ExecutionEngine.Push(Neo.VM.Types.StackItem)">
            <summary>
            Pushes an item onto the top of the current stack.
            </summary>
            <param name="item">The item to be pushed.</param>
        </member>
        <member name="T:Neo.VM.ExecutionEngineLimits">
            <summary>
            Represents the restrictions on the VM.
            </summary>
        </member>
        <member name="F:Neo.VM.ExecutionEngineLimits.Default">
            <summary>
            The default strategy.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngineLimits.MaxShift">
            <summary>
            The maximum number of bits that <see cref="F:Neo.VM.OpCode.SHL"/> and <see cref="F:Neo.VM.OpCode.SHR"/> can shift.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngineLimits.MaxStackSize">
            <summary>
            The maximum number of items that can be contained in the VM's evaluation stacks and slots.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngineLimits.MaxItemSize">
            <summary>
            The maximum size of an item in the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngineLimits.MaxComparableSize">
            <summary>
            The largest comparable size. If a <see cref="T:Neo.VM.Types.ByteString"/> or <see cref="T:Neo.VM.Types.Struct"/> exceeds this size, comparison operations on it cannot be performed in the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngineLimits.MaxInvocationStackSize">
            <summary>
            The maximum number of frames in the invocation stack of the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngineLimits.MaxTryNestingDepth">
            <summary>
            The maximum nesting depth of <see langword="try"/>-<see langword="catch"/>-<see langword="finally"/> blocks.
            </summary>
        </member>
        <member name="P:Neo.VM.ExecutionEngineLimits.CatchEngineExceptions">
            <summary>
            Allow to catch the ExecutionEngine Exceptions
            </summary>
        </member>
        <member name="M:Neo.VM.ExecutionEngineLimits.AssertMaxItemSize(System.Int32)">
            <summary>
            Assert that the size of the item meets the limit.
            </summary>
            <param name="size">The size to be checked.</param>
        </member>
        <member name="M:Neo.VM.ExecutionEngineLimits.AssertShift(System.Int32)">
            <summary>
            Assert that the number of bits shifted meets the limit.
            </summary>
            <param name="shift">The number of bits shifted.</param>
        </member>
        <member name="T:Neo.VM.Instruction">
            <summary>
            Represents instructions in the VM script.
            </summary>
        </member>
        <member name="P:Neo.VM.Instruction.RET">
            <summary>
            Represents the instruction with <see cref="F:Neo.VM.OpCode.RET"/>.
            </summary>
        </member>
        <member name="F:Neo.VM.Instruction.OpCode">
            <summary>
            The <see cref="T:Neo.VM.OpCode"/> of the instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.Instruction.Operand">
            <summary>
            The operand of the instruction.
            </summary>
        </member>
        <member name="P:Neo.VM.Instruction.Size">
            <summary>
            Gets the size of the instruction.
            </summary>
        </member>
        <member name="P:Neo.VM.Instruction.TokenI16">
            <summary>
            Gets the first operand as <see cref="T:System.Int16"/>.
            </summary>
        </member>
        <member name="P:Neo.VM.Instruction.TokenI32">
            <summary>
            Gets the first operand as <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="P:Neo.VM.Instruction.TokenI32_1">
            <summary>
            Gets the second operand as <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="P:Neo.VM.Instruction.TokenI8">
            <summary>
            Gets the first operand as <see cref="T:System.SByte"/>.
            </summary>
        </member>
        <member name="P:Neo.VM.Instruction.TokenI8_1">
            <summary>
            Gets the second operand as <see cref="T:System.SByte"/>.
            </summary>
        </member>
        <member name="P:Neo.VM.Instruction.TokenString">
            <summary>
            Gets the operand as <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="P:Neo.VM.Instruction.TokenU16">
            <summary>
            Gets the first operand as <see cref="T:System.UInt16"/>.
            </summary>
        </member>
        <member name="P:Neo.VM.Instruction.TokenU32">
            <summary>
            Gets the first operand as <see cref="T:System.UInt32"/>.
            </summary>
        </member>
        <member name="P:Neo.VM.Instruction.TokenU8">
            <summary>
            Gets the first operand as <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="P:Neo.VM.Instruction.TokenU8_1">
            <summary>
            Gets the second operand as <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="T:Neo.VM.JumpTable">
            <summary>
            Partial class for performing bitwise and logical operations on integers within a jump table.
            </summary>
            <summary>
            Partial class for manipulating compound types like maps, arrays, and structs within a jump table.
            </summary>
            <summary>
            Partial class for performing bitwise and logical operations on integers within a jump table.
            </summary>
            <remarks>
            For binary operations x1 and x2, x1 is the first pushed onto the evaluation stack (the second popped from the stack),
            x2 is the second pushed onto the evaluation stack (the first popped from the stack)
            </remarks>
            <summary>
            Partial class for mathematical operations within a jump table.
            </summary>
            <remarks>
            For binary operations x1 and x2, x1 is the first pushed onto the evaluation stack (the second popped from the stack),
            x2 is the second pushed onto the evaluation stack (the first popped from the stack)
            </remarks>
            <summary>
            Partial class for providing methods to push various data types onto the evaluation stack within a jump table.
            </summary>
            <remarks>Pop 0, Push 1</remarks>
            <summary>
            Partial class representing a jump table for executing specific operations related to slot manipulation.
            </summary>
            <summary>
            Partial class representing a jump table for executing specific operations related to string manipulation.
            </summary>
            <summary>
            Partial class for stack manipulation within a jump table in the execution engine.
            </summary>
            <summary>
            Partial class for type operations in the execution engine within a jump table.
            </summary>
        </member>
        <member name="M:Neo.VM.JumpTable.Invert(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Flips all of the bits of an integer.
            <see cref="F:Neo.VM.OpCode.INVERT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.And(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the bitwise AND of two integers.
            <see cref="F:Neo.VM.OpCode.AND"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Or(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the bitwise OR of two integers.
            <see cref="F:Neo.VM.OpCode.OR"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.XOr(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the bitwise XOR (exclusive OR) of two integers.
            <see cref="F:Neo.VM.OpCode.XOR"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Equal(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Determines whether two objects are equal according to the execution engine's comparison rules.
            <see cref="F:Neo.VM.OpCode.EQUAL"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.NotEqual(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Determines whether two objects are not equal according to the execution engine's comparison rules.
            <see cref="F:Neo.VM.OpCode.NOTEQUAL"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.PackMap(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Packs a map from the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PACKMAP"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2n+1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.PackStruct(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Packs a struct from the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PACKSTRUCT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop n+1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Pack(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Packs an array from the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PACK"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop n+1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Unpack(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Unpacks a compound type from the evaluation stack.
            <see cref="F:Neo.VM.OpCode.UNPACK"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 2n+1 or n+1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.NewArray0(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Creates a new empty array with zero elements on the evaluation stack.
            <see cref="F:Neo.VM.OpCode.NEWARRAY0"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>
            Pop 0, Push 1
            TODO: Change to NewNullArray method or add it?
            </remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.NewArray(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Creates a new array with a specified number of elements on the evaluation stack.
            <see cref="F:Neo.VM.OpCode.NEWARRAY"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.NewArray_T(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Creates a new array with a specified number of elements and a specified type on the evaluation stack.
            <see cref="F:Neo.VM.OpCode.NEWARRAY_T"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.NewStruct0(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Creates a new empty struct with zero elements on the evaluation stack.
            <see cref="F:Neo.VM.OpCode.NEWSTRUCT0"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 0, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.NewStruct(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Creates a new struct with a specified number of elements on the evaluation stack.
            <see cref="F:Neo.VM.OpCode.NEWSTRUCT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.NewMap(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Creates a new empty map on the evaluation stack.
            <see cref="F:Neo.VM.OpCode.NEWMAP"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 0, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Size(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Gets the size of the top item on the evaluation stack and pushes it onto the stack.
            <see cref="F:Neo.VM.OpCode.SIZE"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.HasKey(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Checks whether the top item on the evaluation stack has the specified key.
            <see cref="F:Neo.VM.OpCode.HASKEY"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Keys(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Retrieves the keys of a map and pushes them onto the evaluation stack as an array.
            <see cref="F:Neo.VM.OpCode.KEYS"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Values(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Retrieves the values of a compound type and pushes them onto the evaluation stack as an array.
            <see cref="F:Neo.VM.OpCode.VALUES"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.PickItem(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Retrieves the item from an array, map, buffer, or byte string based on the specified key,
            and pushes it onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PICKITEM"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Append(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Appends an item to the end of the specified array.
            <see cref="F:Neo.VM.OpCode.APPEND"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.SetItem(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            A value v, index n (or key) and an array (or map) are taken from main stack. Attribution array[n]=v (or map[n]=v) is performed.
            <see cref="F:Neo.VM.OpCode.SETITEM"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 3, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.ReverseItems(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Reverses the order of items in the specified array or buffer.
            <see cref="F:Neo.VM.OpCode.REVERSEITEMS"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Remove(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Removes the item at the specified index from the array or map.
            <see cref="F:Neo.VM.OpCode.REMOVE"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.ClearItems(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Clears all items from the compound type.
            <see cref="F:Neo.VM.OpCode.CLEARITEMS"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.PopItem(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Removes and returns the item at the top of the specified array.
            <see cref="F:Neo.VM.OpCode.POPITEM"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Nop(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            No operation. Does nothing.
            <see cref="F:Neo.VM.OpCode.NOP"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Jmp(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer,
            where the offset is obtained from the first operand of the instruction and interpreted as a signed byte.
            <see cref="F:Neo.VM.OpCode.JMP"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Jmp_L(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer,
            where the offset is obtained from the first operand of the instruction and interpreted as a 32-bit signed integer.
            <see cref="F:Neo.VM.OpCode.JMP_L"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpIf(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the boolean result of popping the evaluation stack is true.
            The offset is obtained from the instruction's first operand interpreted as a signed byte.
            <see cref="F:Neo.VM.OpCode.JMPIF"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 1, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpIf_L(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the boolean result of popping the evaluation stack is true.
            The offset is obtained from the instruction's first operand interpreted as a 32-bit signed integer.
            <see cref="F:Neo.VM.OpCode.JMPIF_L"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 1, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpIfNot(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the boolean result of popping the evaluation stack is false.
            The offset is obtained from the instruction's first operand interpreted as a signed byte.
            <see cref="F:Neo.VM.OpCode.JMPIFNOT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 1, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpIfNot_L(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the boolean result of popping the evaluation stack is false.
            The offset is obtained from the instruction's first operand interpreted as a 32-bit signed integer.
            <see cref="F:Neo.VM.OpCode.JMPIFNOT_L"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 1, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpEq(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the two integers popped from the evaluation stack are equal.
            The offset is obtained from the instruction's first operand interpreted as a signed byte.
            <see cref="F:Neo.VM.OpCode.JMPEQ"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 2, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpEq_L(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the two integers popped from the evaluation stack are equal.
            The offset is obtained from the instruction's first operand interpreted as a 32-bit signed integer.
            <see cref="F:Neo.VM.OpCode.JMPEQ_L"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 2, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpNe(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the two integers popped from the evaluation stack are not equal.
            The offset is obtained from the instruction's first operand interpreted as a signed byte.
            <see cref="F:Neo.VM.OpCode.JMPNE"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 2, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpNe_L(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the two integers popped from the evaluation stack are not equal.
            The offset is obtained from the instruction's first operand interpreted as a 32-bit signed integer.
            <see cref="F:Neo.VM.OpCode.JMPNE_L"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 2, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpGt(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the first integer pushed onto the evaluation stack is greater than the second integer.
            The offset is obtained from the instruction's first operand interpreted as a signed byte.
            <see cref="F:Neo.VM.OpCode.JMPGT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 2, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpGt_L(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the first integer pushed onto the evaluation stack is greater than the second integer.
            The offset is obtained from the instruction's first operand interpreted as a 32-bit signed integer.
            <see cref="F:Neo.VM.OpCode.JMPGT_L"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 2, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpGe(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the first integer pushed onto the evaluation stack is greater than or equal to the second integer.
            The offset is obtained from the instruction's first operand interpreted as a signed byte.
            <see cref="F:Neo.VM.OpCode.JMPGE"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 2, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpGe_L(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the first integer pushed onto the evaluation stack is greater than or equal to the second integer.
            The offset is obtained from the instruction's first operand interpreted as a 32-bit signed integer.
            <see cref="F:Neo.VM.OpCode.JMPGE_L"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 2, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpLt(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the first integer pushed onto the evaluation stack is less than the second integer.
            The offset is obtained from the instruction's first operand interpreted as a signed byte.
            <see cref="F:Neo.VM.OpCode.JMPLT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 2, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpLt_L(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the first integer pushed onto the evaluation stack is less than the second integer.
            The offset is obtained from the instruction's first operand interpreted as a 32-bit signed integer.
            <see cref="F:Neo.VM.OpCode.JMPLT_L"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 2, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpLe(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the first integer pushed onto the evaluation stack is less than or equal to the second integer.
            The offset is obtained from the instruction's first operand interpreted as a signed byte.
            <see cref="F:Neo.VM.OpCode.JMPLE"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 2, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.JmpLe_L(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Jumps to the specified offset from the current instruction pointer
            if the first integer pushed onto the evaluation stack is less than or equal to the second integer.
            The offset is obtained from the instruction's first operand interpreted as a 32-bit signed integer.
            <see cref="F:Neo.VM.OpCode.JMPLE_L"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
            <remarks>Pop 2, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Call(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Calls a method specified by the offset from the current instruction pointer.
            The offset is obtained from the instruction's first operand interpreted as a signed byte.
            <see cref="F:Neo.VM.OpCode.CALL"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Call_L(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Calls a method specified by the offset from the current instruction pointer.
            The offset is obtained from the instruction's first operand interpreted as a 32-bit signed integer.
            <see cref="F:Neo.VM.OpCode.CALL_L"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction containing the offset as the first operand.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.CallA(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Calls a method specified by the pointer pushed onto the evaluation stack.
            It verifies if the pointer belongs to the current script.
            <see cref="F:Neo.VM.OpCode.CALLA"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The current instruction.</param>
            <remarks>Pop 1, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.CallT(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Calls the function described by the token.
            <see cref="F:Neo.VM.OpCode.CALLT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The current instruction.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Abort(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Aborts the execution by turning the virtual machine state to FAULT immediately, and the exception cannot be caught.
            <see cref="F:Neo.VM.OpCode.ABORT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The current instruction.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Assert(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pop the top value of the stack. If it's false, exit vm execution and set vm state to FAULT.
            <see cref="F:Neo.VM.OpCode.ASSERT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The current instruction.</param>
            <remarks>Pop 1, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Throw(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pop the top value of the stack, and throw it.
            <see cref="F:Neo.VM.OpCode.THROW"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The current instruction.</param>
            <remarks>Pop 1, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Try(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Initiates a try block with the specified catch and finally offsets.
            If there's no catch block, set CatchOffset to 0. If there's no finally block, set FinallyOffset to 0.
            where the catch offset is obtained from the first operand of the instruction and interpreted as a signed byte
            the catch offset is obtained from the second operand of the instruction and interpreted as a signed byte.
            <see cref="F:Neo.VM.OpCode.TRY"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The current instruction.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Try_L(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Initiates a try block with the specified catch and finally offsets.
            If there's no catch block, set CatchOffset to 0. If there's no finally block, set FinallyOffset to 0.
            where the catch offset is obtained from the first operand of the instruction and interpreted as a 32-bit signed integer
            the catch offset is obtained from the second operand of the instruction and interpreted as a 32-bit signed integer.
            <see cref="F:Neo.VM.OpCode.TRY_L"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The current instruction.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.EndTry(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Ensures that the appropriate surrounding finally blocks are executed,
            then unconditionally transfers control to the specific target instruction represented as a 1-byte signed offset
            from the beginning of the current instruction.
            <see cref="F:Neo.VM.OpCode.ENDTRY"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The current instruction.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.EndTry_L(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Ensures that the appropriate surrounding finally blocks are executed,
            then unconditionally transfers control to the specific target instruction represented as a 4-byte signed offset
            from the beginning of the current instruction.
            <see cref="F:Neo.VM.OpCode.ENDTRY_L"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The current instruction.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.EndFinally(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Ends the finally block. If no exception occurs or is caught,
            the VM jumps to the target instruction specified by ENDTRY/ENDTRY_L.
            Otherwise, the VM rethrows the exception to the upper layer.
            <see cref="F:Neo.VM.OpCode.ENDFINALLY"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The current instruction.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Ret(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Returns from the current method.
            <see cref="F:Neo.VM.OpCode.RET"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The current instruction.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Syscall(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Calls to an interop service.
            <see cref="F:Neo.VM.OpCode.SYSCALL"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The current instruction.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.ExecuteCall(Neo.VM.ExecutionEngine,System.Int32)">
            <summary>
            Executes a call operation by loading a new execution context at the specified position.
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="position">The position to load the new execution context.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.ExecuteEndTry(Neo.VM.ExecutionEngine,System.Int32)">
            <summary>
            Executes the end of a try block, either popping it from the try stack or transitioning to the finally block.
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="endOffset">The offset to the end of the try block.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.ExecuteJump(Neo.VM.ExecutionEngine,System.Int32)">
            <summary>
            Executes a jump operation to the specified position.
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="position">The position to jump to.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.ExecuteJumpOffset(Neo.VM.ExecutionEngine,System.Int32)">
            <summary>
            Executes a jump operation with the specified offset from the current instruction pointer.
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="offset">The offset from the current instruction pointer.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.ExecuteTry(Neo.VM.ExecutionEngine,System.Int32,System.Int32)">
            <summary>
            Executes a try block operation with the specified catch and finally offsets.
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="catchOffset">The catch block offset.</param>
            <param name="finallyOffset">The finally block offset.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.ExecuteThrow(Neo.VM.ExecutionEngine,Neo.VM.Types.StackItem)">
            <summary>
            Executes a throw operation, handling any surrounding try-catch-finally blocks.
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="ex">The exception to throw.</param>
        </member>
        <member name="F:Neo.VM.JumpTable.Default">
            <summary>
            Default JumpTable
            </summary>
        </member>
        <member name="M:Neo.VM.JumpTable.#ctor">
            <summary>
            Jump table constructor
            </summary>
            <exception cref="T:System.InvalidOperationException">Throw an exception if the opcode was already set</exception>
        </member>
        <member name="M:Neo.VM.JumpTable.Sign(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the sign of the specified integer.
            If the value is negative, puts -1; if positive, puts 1; if zero, puts 0.
            <see cref="F:Neo.VM.OpCode.SIGN"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Abs(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the absolute value of the specified integer.
            <see cref="F:Neo.VM.OpCode.ABS"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Negate(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the negation of the specified integer.
            <see cref="F:Neo.VM.OpCode.NEGATE"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Inc(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Increments the specified integer by one.
            <see cref="F:Neo.VM.OpCode.INC"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Dec(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Decrements the specified integer by one.
            <see cref="F:Neo.VM.OpCode.DEC"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Add(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the sum of two integers.
            <see cref="F:Neo.VM.OpCode.ADD"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Sub(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the difference between two integers.
            <see cref="F:Neo.VM.OpCode.SUB"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Mul(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the product of two integers.
            <see cref="F:Neo.VM.OpCode.MUL"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Div(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the quotient of two integers.
            <see cref="F:Neo.VM.OpCode.DIV"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Mod(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the result of raising a number to the specified power.
            <see cref="F:Neo.VM.OpCode.MOD"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Pow(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the square root of the specified integer.
            <see cref="F:Neo.VM.OpCode.POW"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Sqrt(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            
            <see cref="F:Neo.VM.OpCode.SQRT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.ModMul(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the modular multiplication of two integers.
            <see cref="F:Neo.VM.OpCode.MODMUL"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 3, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.ModPow(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the modular exponentiation of an integer.
            <see cref="F:Neo.VM.OpCode.MODPOW"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 3, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Shl(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the left shift of an integer.
            <see cref="F:Neo.VM.OpCode.SHL"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Shr(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the right shift of an integer.
            <see cref="F:Neo.VM.OpCode.SHR"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Not(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            If the input is 0 or 1, it is flipped. Otherwise the output will be 0.
            <see cref="F:Neo.VM.OpCode.NOT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.BoolAnd(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the logical AND of the top two stack items and pushes the result onto the stack.
            <see cref="F:Neo.VM.OpCode.BOOLAND"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.BoolOr(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the logical OR of the top two stack items and pushes the result onto the stack.
            <see cref="F:Neo.VM.OpCode.BOOLOR"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Nz(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Determines whether the top stack item is not zero and pushes the result onto the stack.
            <see cref="F:Neo.VM.OpCode.NZ"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.NumEqual(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Determines whether the top two stack items are equal and pushes the result onto the stack.
            <see cref="F:Neo.VM.OpCode.NUMEQUAL"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.NumNotEqual(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Determines whether the top two stack items are not equal and pushes the result onto the stack.
            <see cref="F:Neo.VM.OpCode.NUMNOTEQUAL"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Lt(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Determines whether the two integer at the top of the stack, x1 are less than x2, and pushes the result onto the stack.
            <see cref="F:Neo.VM.OpCode.LT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Le(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Determines whether the two integer at the top of the stack, x1 are less than or equal to x2, and pushes the result onto the stack.
            <see cref="F:Neo.VM.OpCode.LE"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Gt(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Determines whether the two integer at the top of the stack, x1 are greater than x2, and pushes the result onto the stack.
            <see cref="F:Neo.VM.OpCode.GT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Ge(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Determines whether the two integer at the top of the stack, x1 are greater than or equal to x2, and pushes the result onto the stack.
            <see cref="F:Neo.VM.OpCode.GE"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Min(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the minimum of the top two stack items and pushes the result onto the stack.
            <see cref="F:Neo.VM.OpCode.MIN"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Max(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Computes the maximum of the top two stack items and pushes the result onto the stack.
            <see cref="F:Neo.VM.OpCode.MAX"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Within(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Determines whether the top stack item is within the range specified by the next two top stack items
            and pushes the result onto the stack.
            <see cref="F:Neo.VM.OpCode.WITHIN"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 3, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.PushInt8(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes an 8-bit signed integer onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSHINT8"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.PushInt16(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes an 16-bit signed integer onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSHINT16"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.PushInt32(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes an 32-bit signed integer onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSHINT32"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.PushInt64(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes an 64-bit signed integer onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSHINT64"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.PushInt128(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes an 128-bit signed integer onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSHINT128"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.PushInt256(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes an 256-bit signed integer onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSHINT256"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.PushT(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes a boolean value of true onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSHT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.PushF(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes a boolean value of false onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSHF"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.PushA(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the address of the specified instruction onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSHA"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.PushNull(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes a null onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSHNULL"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.PushData1(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes a byte array with a length prefix onto the evaluation stack.
            The length of the array is 1 byte.
            <see cref="F:Neo.VM.OpCode.PUSHDATA1"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.PushData2(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes a byte array with a length prefix onto the evaluation stack.
            The length of the array is 1 bytes.
            <see cref="F:Neo.VM.OpCode.PUSHDATA2"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.PushData4(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes a byte array with a length prefix onto the evaluation stack.
            The length of the array is 4 bytes.
            <see cref="F:Neo.VM.OpCode.PUSHDATA4"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.PushM1(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of -1 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSHM1"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push0(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 0 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH0"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push1(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 1 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH1"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push2(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 2 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH2"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push3(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 3 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH3"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push4(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 4 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH4"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push5(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 5 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH5"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push6(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 6 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH6"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push7(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 7 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH7"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push8(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 8 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH8"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push9(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 9 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH9"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push10(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 10 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH10"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push11(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 11 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH11"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push12(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 12 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH12"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push13(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 13 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH13"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push14(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 14 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH14"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push15(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 15 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH15"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Push16(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the integer value of 16 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.PUSH16"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.InitSSlot(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Initializes the static field slot in the current execution context.
            <see cref="F:Neo.VM.OpCode.INITSSLOT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.InitSlot(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Initializes the local variable slot or the argument slot in the current execution context.
            <see cref="F:Neo.VM.OpCode.INITSLOT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdSFld0(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the value at index 0 from the static field slot onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDSFLD0"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdSFld1(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the value at index 1 from the static field slot onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDSFLD1"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdSFld2(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the value at index 2 from the static field slot onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDSFLD2"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdSFld3(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the value at index 3 from the static field slot onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDSFLD3"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdSFld4(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the value at index 4 from the static field slot onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDSFLD4"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdSFld5(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the value at index 5 from the static field slot onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDSFLD5"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdSFld6(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the value at index 6 from the static field slot onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDSFLD6"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdSFld(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the static field at a specified index onto the evaluation stack.
            The index is represented as a 1-byte unsigned integer.
            <see cref="F:Neo.VM.OpCode.LDSFLD"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StSFld0(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value at index 0 from the evaluation stack into the static field slot.
            <see cref="F:Neo.VM.OpCode.STSFLD0"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StSFld1(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value at index 1 from the evaluation stack into the static field slot.
            <see cref="F:Neo.VM.OpCode.STSFLD1"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StSFld2(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value at index 2 from the evaluation stack into the static field slot.
            <see cref="F:Neo.VM.OpCode.STSFLD2"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StSFld3(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value at index 3 from the evaluation stack into the static field slot.
            <see cref="F:Neo.VM.OpCode.STSFLD3"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StSFld4(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value at index 4 from the evaluation stack into the static field slot.
            <see cref="F:Neo.VM.OpCode.STSFLD4"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StSFld5(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value at index 5 from the evaluation stack into the static field slot.
            <see cref="F:Neo.VM.OpCode.STSFLD5"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StSFld6(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value at index 6 from the evaluation stack into the static field slot.
            <see cref="F:Neo.VM.OpCode.STSFLD6"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StSFld(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the static field list at a specified index.
            The index is represented as a 1-byte unsigned integer.
            <see cref="F:Neo.VM.OpCode.STSFLD"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdLoc0(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the local variable at index 0 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDLOC0"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdLoc1(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the local variable at index 1 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDLOC1"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdLoc2(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the local variable at index 2 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDLOC2"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdLoc3(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the local variable at index 3 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDLOC3"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdLoc4(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the local variable at index 4 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDLOC4"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdLoc5(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the local variable at index 5 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDLOC5"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdLoc6(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the local variable at index 6 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDLOC6"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdLoc(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the local variable at a specified index onto the evaluation stack.
            The index is represented as a 1-byte unsigned integer.
            <see cref="F:Neo.VM.OpCode.LDLOC"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StLoc0(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at index 0.
            <see cref="F:Neo.VM.OpCode.STLOC0"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StLoc1(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at index 1.
            <see cref="F:Neo.VM.OpCode.STLOC1"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StLoc2(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at index 2.
            <see cref="F:Neo.VM.OpCode.STLOC2"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StLoc3(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at index 3.
            <see cref="F:Neo.VM.OpCode.STLOC3"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StLoc4(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at index 4.
            <see cref="F:Neo.VM.OpCode.STLOC4"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StLoc5(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at index 5.
            <see cref="F:Neo.VM.OpCode.STLOC5"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StLoc6(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at index 6.
            <see cref="F:Neo.VM.OpCode.STLOC6"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StLoc(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at a specified index.
            The index is represented as a 1-byte unsigned integer.
            <see cref="F:Neo.VM.OpCode.STLOC"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdArg0(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the argument at index 0 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDARG0"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdArg1(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the argument at index 1 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDARG1"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdArg2(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the argument at index 2 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDARG2"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdArg3(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the argument at index 3 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDARG3"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdArg4(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the argument at index 4 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDARG4"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdArg5(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the argument at index 5 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDARG5"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdArg6(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the argument at index 6 onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LDARG6"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.LdArg(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Loads the argument at a specified index onto the evaluation stack.
            The index is represented as a 1-byte unsigned integer.
            <see cref="F:Neo.VM.OpCode.LDARG"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StArg0(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at index 0.
            <see cref="F:Neo.VM.OpCode.STARG0"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StArg1(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at index 1.
            <see cref="F:Neo.VM.OpCode.STARG1"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StArg2(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at index 2.
            <see cref="F:Neo.VM.OpCode.STARG2"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StArg3(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at index 3.
            <see cref="F:Neo.VM.OpCode.STARG3"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StArg4(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at index 4.
            <see cref="F:Neo.VM.OpCode.STARG4"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StArg5(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at index 5.
            <see cref="F:Neo.VM.OpCode.STARG5"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StArg6(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at index 6.
            <see cref="F:Neo.VM.OpCode.STARG6"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.StArg(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at a specified index.
            The index is represented as a 1-byte unsigned integer.
            <see cref="F:Neo.VM.OpCode.STARG"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.ExecuteStoreToSlot(Neo.VM.ExecutionEngine,Neo.VM.Slot,System.Int32)">
            <summary>
            Executes the store operation into the specified slot at the given index.
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="slot">The slot to store the value.</param>
            <param name="index">The index within the slot.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.ExecuteLoadFromSlot(Neo.VM.ExecutionEngine,Neo.VM.Slot,System.Int32)">
            <summary>
            Executes the load operation from the specified slot at the given index onto the evaluation stack.
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="slot">The slot to load the value from.</param>
            <param name="index">The index within the slot.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.NewBuffer(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Creates a new buffer with the specified length and pushes it onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.NEWBUFFER"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Memcpy(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Copies a specified number of bytes from one buffer to another buffer.
            <see cref="F:Neo.VM.OpCode.MEMCPY"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 5, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Cat(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Concatenates two buffers and pushes the result onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.CAT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.SubStr(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Extracts a substring from the specified buffer and pushes it onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.CAT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 3, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Left(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Extracts a specified number of characters from the left side of the buffer and pushes them onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.LEFT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Right(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Extracts a specified number of characters from the right side of the buffer and pushes them onto the evaluation stack.
            <see cref="F:Neo.VM.OpCode.RIGHT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Depth(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Pushes the number of stack items in the evaluation stack onto the stack.
            <see cref="F:Neo.VM.OpCode.DEPTH"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 0, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Drop(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Removes the top item from the evaluation stack.
            <see cref="F:Neo.VM.OpCode.DROP"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Nip(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            
            <see cref="F:Neo.VM.OpCode.NIP"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.XDrop(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Removes the nth item from the top of the evaluation stack.
            <see cref="F:Neo.VM.OpCode.XDROP"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Clear(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Clears all items from the evaluation stack.
            <see cref="F:Neo.VM.OpCode.CLEAR"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Dup(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Duplicates the item on the top of the evaluation stack.
            <see cref="F:Neo.VM.OpCode.DUP"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 0, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Over(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Copies the second item from the top of the evaluation stack and pushes the copy onto the stack.
            <see cref="F:Neo.VM.OpCode.OVER"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 0, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Pick(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Copies the nth item from the top of the evaluation stack and pushes the copy onto the stack.
            <see cref="F:Neo.VM.OpCode.PICK"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Tuck(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Copies the top item on the evaluation stack and inserts the copy between the first and second items.
            <see cref="F:Neo.VM.OpCode.TUCK"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Swap(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Swaps the top two items on the evaluation stack.
            <see cref="F:Neo.VM.OpCode.SWAP"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 0, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Rot(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Left rotates the top three items on the evaluation stack.
            <see cref="F:Neo.VM.OpCode.ROT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 0, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Roll(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            The item n back in the stack is moved to the top.
            <see cref="F:Neo.VM.OpCode.ROLL"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Reverse3(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Reverses the order of the top 3 items on the evaluation stack.
            <see cref="F:Neo.VM.OpCode.REVERSE3"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.Reverse4(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Reverses the order of the top 4 items on the evaluation stack.
            <see cref="F:Neo.VM.OpCode.REVERSE4"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
        </member>
        <member name="M:Neo.VM.JumpTable.ReverseN(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Reverses the order of the top n items on the evaluation stack.
            <see cref="F:Neo.VM.OpCode.REVERSEN"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.IsNull(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Determines whether the item on top of the evaluation stack is null.
            <see cref="F:Neo.VM.OpCode.ISNULL"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.IsType(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Determines whether the item on top of the evaluation stack has a specified type.
            <see cref="F:Neo.VM.OpCode.ISTYPE"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.Convert(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Converts the item on top of the evaluation stack to a specified type.
            <see cref="F:Neo.VM.OpCode.CONVERT"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 1</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.AbortMsg(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Aborts execution with a specified message.
            <see cref="F:Neo.VM.OpCode.ABORTMSG"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 1, Push 0</remarks>
        </member>
        <member name="M:Neo.VM.JumpTable.AssertMsg(Neo.VM.ExecutionEngine,Neo.VM.Instruction)">
            <summary>
            Asserts a condition with a specified message, throwing an exception if the condition is false.
            <see cref="F:Neo.VM.OpCode.ASSERTMSG"/>
            </summary>
            <param name="engine">The execution engine.</param>
            <param name="instruction">The instruction being executed.</param>
            <remarks>Pop 2, Push 0</remarks>
        </member>
        <member name="T:Neo.VM.OpCode">
            <summary>
            Represents the opcode of an <see cref="T:Neo.VM.Instruction"/>.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSHINT8">
            <summary>
            Pushes a 1-byte signed integer onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSHINT16">
            <summary>
            Pushes a 2-bytes signed integer onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSHINT32">
            <summary>
            Pushes a 4-bytes signed integer onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSHINT64">
            <summary>
            Pushes a 8-bytes signed integer onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSHINT128">
            <summary>
            Pushes a 16-bytes signed integer onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSHINT256">
            <summary>
            Pushes a 32-bytes signed integer onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSHT">
            <summary>
            Pushes the boolean value <see langword="true"/> onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSHF">
            <summary>
            Pushes the boolean value <see langword="false"/> onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSHA">
            <summary>
            Converts the 4-bytes offset to an <see cref="T:Neo.VM.Types.Pointer"/>, and pushes it onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSHNULL">
            <summary>
            The item <see langword="null"/> is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSHDATA1">
            <summary>
            The next byte contains the number of bytes to be pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSHDATA2">
            <summary>
            The next two bytes contain the number of bytes to be pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSHDATA4">
            <summary>
            The next four bytes contain the number of bytes to be pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSHM1">
            <summary>
            The number -1 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH0">
            <summary>
            The number 0 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH1">
            <summary>
            The number 1 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH2">
            <summary>
            The number 2 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH3">
            <summary>
            The number 3 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH4">
            <summary>
            The number 4 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH5">
            <summary>
            The number 5 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH6">
            <summary>
            The number 6 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH7">
            <summary>
            The number 7 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH8">
            <summary>
            The number 8 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH9">
            <summary>
            The number 9 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH10">
            <summary>
            The number 10 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH11">
            <summary>
            The number 11 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH12">
            <summary>
            The number 12 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH13">
            <summary>
            The number 13 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH14">
            <summary>
            The number 14 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH15">
            <summary>
            The number 15 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PUSH16">
            <summary>
            The number 16 is pushed onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NOP">
            <summary>
            The <see cref="F:Neo.VM.OpCode.NOP"/> operation does nothing. It is intended to fill in space if opcodes are patched.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMP">
            <summary>
            Unconditionally transfers control to a target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMP_L">
            <summary>
            Unconditionally transfers control to a target instruction. The target instruction is represented as a 4-bytes signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPIF">
            <summary>
            Transfers control to a target instruction if the value is <see langword="true"/>, not <see langword="null"/>, or non-zero. The target instruction is represented as a 1-byte signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPIF_L">
            <summary>
            Transfers control to a target instruction if the value is <see langword="true"/>, not <see langword="null"/>, or non-zero. The target instruction is represented as a 4-bytes signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPIFNOT">
            <summary>
            Transfers control to a target instruction if the value is <see langword="false"/>, a <see langword="null"/> reference, or zero. The target instruction is represented as a 1-byte signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPIFNOT_L">
            <summary>
            Transfers control to a target instruction if the value is <see langword="false"/>, a <see langword="null"/> reference, or zero. The target instruction is represented as a 4-bytes signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPEQ">
            <summary>
            Transfers control to a target instruction if two values are equal. The target instruction is represented as a 1-byte signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPEQ_L">
            <summary>
            Transfers control to a target instruction if two values are equal. The target instruction is represented as a 4-bytes signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPNE">
            <summary>
            Transfers control to a target instruction when two values are not equal. The target instruction is represented as a 1-byte signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPNE_L">
            <summary>
            Transfers control to a target instruction when two values are not equal. The target instruction is represented as a 4-bytes signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPGT">
            <summary>
            Transfers control to a target instruction if the first value is greater than the second value. The target instruction is represented as a 1-byte signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPGT_L">
            <summary>
            Transfers control to a target instruction if the first value is greater than the second value. The target instruction is represented as a 4-bytes signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPGE">
            <summary>
            Transfers control to a target instruction if the first value is greater than or equal to the second value. The target instruction is represented as a 1-byte signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPGE_L">
            <summary>
            Transfers control to a target instruction if the first value is greater than or equal to the second value. The target instruction is represented as a 4-bytes signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPLT">
            <summary>
            Transfers control to a target instruction if the first value is less than the second value. The target instruction is represented as a 1-byte signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPLT_L">
            <summary>
            Transfers control to a target instruction if the first value is less than the second value. The target instruction is represented as a 4-bytes signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPLE">
            <summary>
            Transfers control to a target instruction if the first value is less than or equal to the second value. The target instruction is represented as a 1-byte signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.JMPLE_L">
            <summary>
            Transfers control to a target instruction if the first value is less than or equal to the second value. The target instruction is represented as a 4-bytes signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.CALL">
            <summary>
            Calls the function at the target address which is represented as a 1-byte signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.CALL_L">
            <summary>
            Calls the function at the target address which is represented as a 4-bytes signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.CALLA">
            <summary>
            Pop the address of a function from the stack, and call the function.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.CALLT">
            <summary>
            Calls the function which is described by the token.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.ABORT">
            <summary>
            It turns the vm state to FAULT immediately, and cannot be caught.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.ASSERT">
            <summary>
            Pop the top value of the stack. If it's false, exit vm execution and set vm state to FAULT.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.THROW">
            <summary>
            Pop the top value of the stack, and throw it.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.TRY">
            <summary>
            TRY CatchOffset(sbyte) FinallyOffset(sbyte). If there's no catch body, set CatchOffset 0. If there's no finally body, set FinallyOffset 0.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.TRY_L">
            <summary>
            TRY_L CatchOffset(int) FinallyOffset(int). If there's no catch body, set CatchOffset 0. If there's no finally body, set FinallyOffset 0.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.ENDTRY">
            <summary>
            Ensures that the appropriate surrounding finally blocks are executed. And then unconditionally transfers control to the specific target instruction, represented as a 1-byte signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.ENDTRY_L">
            <summary>
            Ensures that the appropriate surrounding finally blocks are executed. And then unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the current instruction.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.ENDFINALLY">
            <summary>
            End finally, If no exception happen or be catched, vm will jump to the target instruction of ENDTRY/ENDTRY_L. Otherwise vm will rethrow the exception to upper layer.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.RET">
            <summary>
            Returns from the current method.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.SYSCALL">
            <summary>
            Calls to an interop service.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.DEPTH">
            <summary>
            Puts the number of stack items onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.DROP">
            <summary>
            Removes the top stack item.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NIP">
            <summary>
            Removes the second-to-top stack item.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.XDROP">
            <summary>
            The item n back in the main stack is removed.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.CLEAR">
            <summary>
            Clear the stack
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.DUP">
            <summary>
            Duplicates the top stack item.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.OVER">
            <summary>
            Copies the second-to-top stack item to the top.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PICK">
            <summary>
            The item n back in the stack is copied to the top.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.TUCK">
            <summary>
            The item at the top of the stack is copied and inserted before the second-to-top item.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.SWAP">
            <summary>
            The top two items on the stack are swapped.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.ROT">
            <summary>
            The top three items on the stack are rotated to the left.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.ROLL">
            <summary>
            The item n back in the stack is moved to the top.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.REVERSE3">
            <summary>
            Reverse the order of the top 3 items on the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.REVERSE4">
            <summary>
            Reverse the order of the top 4 items on the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.REVERSEN">
            <summary>
            Pop the number N on the stack, and reverse the order of the top N items on the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.INITSSLOT">
            <summary>
            Initialize the static field list for the current execution context.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.INITSLOT">
            <summary>
            Initialize the argument slot and the local variable list for the current execution context.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDSFLD0">
            <summary>
            Loads the static field at index 0 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDSFLD1">
            <summary>
            Loads the static field at index 1 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDSFLD2">
            <summary>
            Loads the static field at index 2 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDSFLD3">
            <summary>
            Loads the static field at index 3 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDSFLD4">
            <summary>
            Loads the static field at index 4 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDSFLD5">
            <summary>
            Loads the static field at index 5 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDSFLD6">
            <summary>
            Loads the static field at index 6 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDSFLD">
            <summary>
            Loads the static field at a specified index onto the evaluation stack. The index is represented as a 1-byte unsigned integer.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STSFLD0">
            <summary>
            Stores the value on top of the evaluation stack in the static field list at index 0.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STSFLD1">
            <summary>
            Stores the value on top of the evaluation stack in the static field list at index 1.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STSFLD2">
            <summary>
            Stores the value on top of the evaluation stack in the static field list at index 2.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STSFLD3">
            <summary>
            Stores the value on top of the evaluation stack in the static field list at index 3.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STSFLD4">
            <summary>
            Stores the value on top of the evaluation stack in the static field list at index 4.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STSFLD5">
            <summary>
            Stores the value on top of the evaluation stack in the static field list at index 5.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STSFLD6">
            <summary>
            Stores the value on top of the evaluation stack in the static field list at index 6.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STSFLD">
            <summary>
            Stores the value on top of the evaluation stack in the static field list at a specified index. The index is represented as a 1-byte unsigned integer.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDLOC0">
            <summary>
            Loads the local variable at index 0 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDLOC1">
            <summary>
            Loads the local variable at index 1 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDLOC2">
            <summary>
            Loads the local variable at index 2 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDLOC3">
            <summary>
            Loads the local variable at index 3 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDLOC4">
            <summary>
            Loads the local variable at index 4 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDLOC5">
            <summary>
            Loads the local variable at index 5 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDLOC6">
            <summary>
            Loads the local variable at index 6 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDLOC">
            <summary>
            Loads the local variable at a specified index onto the evaluation stack. The index is represented as a 1-byte unsigned integer.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STLOC0">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at index 0.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STLOC1">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at index 1.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STLOC2">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at index 2.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STLOC3">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at index 3.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STLOC4">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at index 4.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STLOC5">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at index 5.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STLOC6">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at index 6.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STLOC">
            <summary>
            Stores the value on top of the evaluation stack in the local variable list at a specified index. The index is represented as a 1-byte unsigned integer.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDARG0">
            <summary>
            Loads the argument at index 0 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDARG1">
            <summary>
            Loads the argument at index 1 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDARG2">
            <summary>
            Loads the argument at index 2 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDARG3">
            <summary>
            Loads the argument at index 3 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDARG4">
            <summary>
            Loads the argument at index 4 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDARG5">
            <summary>
            Loads the argument at index 5 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDARG6">
            <summary>
            Loads the argument at index 6 onto the evaluation stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LDARG">
            <summary>
            Loads the argument at a specified index onto the evaluation stack. The index is represented as a 1-byte unsigned integer.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STARG0">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at index 0.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STARG1">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at index 1.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STARG2">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at index 2.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STARG3">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at index 3.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STARG4">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at index 4.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STARG5">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at index 5.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STARG6">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at index 6.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.STARG">
            <summary>
            Stores the value on top of the evaluation stack in the argument slot at a specified index. The index is represented as a 1-byte unsigned integer.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NEWBUFFER">
            <summary>
            Creates a new <see cref="T:Neo.VM.Types.Buffer"/> and pushes it onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.MEMCPY">
            <summary>
            Copies a range of bytes from one <see cref="T:Neo.VM.Types.Buffer"/> to another.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.CAT">
            <summary>
            Concatenates two strings.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.SUBSTR">
            <summary>
            Returns a section of a string.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LEFT">
            <summary>
            Keeps only characters left of the specified point in a string.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.RIGHT">
            <summary>
            Keeps only characters right of the specified point in a string.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.INVERT">
            <summary>
            Flips all of the bits in the input.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.AND">
            <summary>
            Boolean and between each bit in the inputs.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.OR">
            <summary>
            Boolean or between each bit in the inputs.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.XOR">
            <summary>
            Boolean exclusive or between each bit in the inputs.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.EQUAL">
            <summary>
            Returns 1 if the inputs are exactly equal, 0 otherwise.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NOTEQUAL">
            <summary>
            Returns 1 if the inputs are not equal, 0 otherwise.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.SIGN">
            <summary>
            Puts the sign of top stack item on top of the main stack. If value is negative, put -1; if positive, put 1; if value is zero, put 0.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.ABS">
            <summary>
            The input is made positive.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NEGATE">
            <summary>
            The sign of the input is flipped.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.INC">
            <summary>
            1 is added to the input.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.DEC">
            <summary>
            1 is subtracted from the input.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.ADD">
            <summary>
            a is added to b.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.SUB">
            <summary>
            b is subtracted from a.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.MUL">
            <summary>
            a is multiplied by b.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.DIV">
            <summary>
            a is divided by b.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.MOD">
            <summary>
            Returns the remainder after dividing a by b.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.POW">
            <summary>
            The result of raising value to the exponent power.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.SQRT">
            <summary>
            Returns the square root of a specified number.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.MODMUL">
            <summary>
            Performs modulus division on a number multiplied by another number.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.MODPOW">
            <summary>
            Performs modulus division on a number raised to the power of another number. If the exponent is -1, it will have the calculation of the modular inverse.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.SHL">
            <summary>
            Shifts a left b bits, preserving sign.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.SHR">
            <summary>
            Shifts a right b bits, preserving sign.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NOT">
            <summary>
            If the input is 0 or 1, it is flipped. Otherwise the output will be 0.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.BOOLAND">
            <summary>
            If both a and b are not 0, the output is 1. Otherwise 0.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.BOOLOR">
            <summary>
            If a or b is not 0, the output is 1. Otherwise 0.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NZ">
            <summary>
            Returns 0 if the input is 0. 1 otherwise.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NUMEQUAL">
            <summary>
            Returns 1 if the numbers are equal, 0 otherwise.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NUMNOTEQUAL">
            <summary>
            Returns 1 if the numbers are not equal, 0 otherwise.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LT">
            <summary>
            Returns 1 if a is less than b, 0 otherwise.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.LE">
            <summary>
            Returns 1 if a is less than or equal to b, 0 otherwise.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.GT">
            <summary>
            Returns 1 if a is greater than b, 0 otherwise.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.GE">
            <summary>
            Returns 1 if a is greater than or equal to b, 0 otherwise.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.MIN">
            <summary>
            Returns the smaller of a and b.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.MAX">
            <summary>
            Returns the larger of a and b.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.WITHIN">
            <summary>
            Returns 1 if x is within the specified range (left-inclusive), 0 otherwise.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PACKMAP">
            <summary>
            A value n is taken from top of main stack. The next n*2 items on main stack are removed, put inside n-sized map and this map is put on top of the main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PACKSTRUCT">
            <summary>
            A value n is taken from top of main stack. The next n items on main stack are removed, put inside n-sized struct and this struct is put on top of the main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PACK">
            <summary>
            A value n is taken from top of main stack. The next n items on main stack are removed, put inside n-sized array and this array is put on top of the main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.UNPACK">
            <summary>
            A collection is removed from top of the main stack. Its elements are put on top of the main stack (in reverse order) and the collection size is also put on main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NEWARRAY0">
            <summary>
            An empty array (with size 0) is put on top of the main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NEWARRAY">
            <summary>
            A value n is taken from top of main stack. A null-filled array with size n is put on top of the main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NEWARRAY_T">
            <summary>
            A value n is taken from top of main stack. An array of type T with size n is put on top of the main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NEWSTRUCT0">
            <summary>
            An empty struct (with size 0) is put on top of the main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NEWSTRUCT">
            <summary>
            A value n is taken from top of main stack. A zero-filled struct with size n is put on top of the main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.NEWMAP">
            <summary>
            A Map is created and put on top of the main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.SIZE">
            <summary>
            An array is removed from top of the main stack. Its size is put on top of the main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.HASKEY">
            <summary>
            An input index n (or key) and an array (or map) are removed from the top of the main stack. Puts True on top of main stack if array[n] (or map[n]) exist, and False otherwise.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.KEYS">
            <summary>
            A map is taken from top of the main stack. The keys of this map are put on top of the main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.VALUES">
            <summary>
            A map is taken from top of the main stack. The values of this map are put on top of the main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.PICKITEM">
            <summary>
            An input index n (or key) and an array (or map) are taken from main stack. Element array[n] (or map[n]) is put on top of the main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.APPEND">
            <summary>
            The item on top of main stack is removed and appended to the second item on top of the main stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.SETITEM">
            <summary>
            A value v, index n (or key) and an array (or map) are taken from main stack. Attribution array[n]=v (or map[n]=v) is performed.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.REVERSEITEMS">
            <summary>
            An array is removed from the top of the main stack and its elements are reversed.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.REMOVE">
            <summary>
            An input index n (or key) and an array (or map) are removed from the top of the main stack. Element array[n] (or map[n]) is removed.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.CLEARITEMS">
            <summary>
            Remove all the items from the compound-type.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.POPITEM">
            <summary>
            Remove the last element from an array, and push it onto the stack.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.ISNULL">
            <summary>
            Returns <see langword="true"/> if the input is <see langword="null"/>;
            <see langword="false"/> otherwise.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.ISTYPE">
            <summary>
            Returns <see langword="true"/> if the top item of the stack is of the specified type;
            <see langword="false"/> otherwise.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.CONVERT">
            <summary>
            Converts the top item of the stack to the specified type.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.ABORTMSG">
            <summary>
            Pops the top stack item. Then, turns the vm state to FAULT immediately, and cannot be caught. The top stack
            value is used as reason.
            </summary>
        </member>
        <member name="F:Neo.VM.OpCode.ASSERTMSG">
            <summary>
            Pops the top two stack items. If the second-to-top stack value is false, exits the vm execution and sets the
            vm state to FAULT. In this case, the top stack value is used as reason for the exit. Otherwise, it is ignored.
            </summary>
        </member>
        <member name="T:Neo.VM.OperandSizeAttribute">
            <summary>
            Indicates the operand length of an <see cref="T:Neo.VM.OpCode"/>.
            </summary>
        </member>
        <member name="P:Neo.VM.OperandSizeAttribute.Size">
            <summary>
            When it is greater than 0, indicates the size of the operand.
            </summary>
        </member>
        <member name="P:Neo.VM.OperandSizeAttribute.SizePrefix">
            <summary>
            When it is greater than 0, indicates the size prefix of the operand.
            </summary>
        </member>
        <member name="T:Neo.VM.ReferenceCounter">
            <summary>
            Used for reference counting of objects in the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.ReferenceCounter.Count">
            <summary>
            Indicates the number of this counter.
            </summary>
        </member>
        <member name="T:Neo.VM.Script">
            <summary>
            Represents the script executed in the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.Script.Length">
            <summary>
            The length of the script.
            </summary>
        </member>
        <member name="P:Neo.VM.Script.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Neo.VM.OpCode"/> at the specified index.
            </summary>
            <param name="index">The index to locate.</param>
            <returns>The <see cref="T:Neo.VM.OpCode"/> at the specified index.</returns>
        </member>
        <member name="M:Neo.VM.Script.#ctor(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:Neo.VM.Script"/> class.
            </summary>
            <param name="script">The bytecodes of the script.</param>
        </member>
        <member name="M:Neo.VM.Script.#ctor(System.ReadOnlyMemory{System.Byte},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Neo.VM.Script"/> class.
            </summary>
            <param name="script">The bytecodes of the script.</param>
            <param name="strictMode">
            Indicates whether strict mode is enabled.
            In strict mode, the script will be checked, but the loading speed will be slower.
            </param>
            <exception cref="T:Neo.VM.BadScriptException">In strict mode, the script was found to contain bad instructions.</exception>
        </member>
        <member name="M:Neo.VM.Script.GetInstruction(System.Int32)">
            <summary>
            Get the <see cref="T:Neo.VM.Instruction"/> at the specified position.
            </summary>
            <param name="ip">The position to get the <see cref="T:Neo.VM.Instruction"/>.</param>
            <returns>The <see cref="T:Neo.VM.Instruction"/> at the specified position.</returns>
            <exception cref="T:System.ArgumentException">In strict mode, the <see cref="T:Neo.VM.Instruction"/> was not found at the specified position.</exception>
        </member>
        <member name="T:Neo.VM.ScriptBuilder">
            <summary>
            A helper class for building scripts.
            </summary>
        </member>
        <member name="P:Neo.VM.ScriptBuilder.Length">
            <summary>
            The length of the script.
            </summary>
        </member>
        <member name="M:Neo.VM.ScriptBuilder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Neo.VM.ScriptBuilder"/> class.
            </summary>
        </member>
        <member name="M:Neo.VM.ScriptBuilder.Emit(Neo.VM.OpCode,System.ReadOnlySpan{System.Byte})">
            <summary>
            Emits an <see cref="T:Neo.VM.Instruction"/> with the specified <see cref="T:Neo.VM.OpCode"/> and operand.
            </summary>
            <param name="opcode">The <see cref="T:Neo.VM.OpCode"/> to be emitted.</param>
            <param name="operand">The operand to be emitted.</param>
            <returns>A reference to this instance after the emit operation has completed.</returns>
        </member>
        <member name="M:Neo.VM.ScriptBuilder.EmitCall(System.Int32)">
            <summary>
            Emits a call <see cref="T:Neo.VM.Instruction"/> with the specified offset.
            </summary>
            <param name="offset">The offset to be called.</param>
            <returns>A reference to this instance after the emit operation has completed.</returns>
        </member>
        <member name="M:Neo.VM.ScriptBuilder.EmitJump(Neo.VM.OpCode,System.Int32)">
            <summary>
            Emits a jump <see cref="T:Neo.VM.Instruction"/> with the specified offset.
            </summary>
            <param name="opcode">The <see cref="T:Neo.VM.OpCode"/> to be emitted. It must be a jump <see cref="T:Neo.VM.OpCode"/></param>
            <param name="offset">The offset to jump.</param>
            <returns>A reference to this instance after the emit operation has completed.</returns>
        </member>
        <member name="M:Neo.VM.ScriptBuilder.EmitPush(System.Numerics.BigInteger)">
            <summary>
            Emits a push <see cref="T:Neo.VM.Instruction"/> with the specified number.
            </summary>
            <param name="value">The number to be pushed.</param>
            <returns>A reference to this instance after the emit operation has completed.</returns>
        </member>
        <member name="M:Neo.VM.ScriptBuilder.EmitPush(System.Boolean)">
            <summary>
            Emits a push <see cref="T:Neo.VM.Instruction"/> with the specified boolean value.
            </summary>
            <param name="value">The value to be pushed.</param>
            <returns>A reference to this instance after the emit operation has completed.</returns>
        </member>
        <member name="M:Neo.VM.ScriptBuilder.EmitPush(System.ReadOnlySpan{System.Byte})">
            <summary>
            Emits a push <see cref="T:Neo.VM.Instruction"/> with the specified data.
            </summary>
            <param name="data">The data to be pushed.</param>
            <returns>A reference to this instance after the emit operation has completed.</returns>
        </member>
        <member name="M:Neo.VM.ScriptBuilder.EmitPush(System.String)">
            <summary>
            Emits a push <see cref="T:Neo.VM.Instruction"/> with the specified <see cref="T:System.String"/>.
            </summary>
            <param name="data">The <see cref="T:System.String"/> to be pushed.</param>
            <returns>A reference to this instance after the emit operation has completed.</returns>
        </member>
        <member name="M:Neo.VM.ScriptBuilder.EmitRaw(System.ReadOnlySpan{System.Byte})">
            <summary>
            Emits raw script.
            </summary>
            <param name="script">The raw script to be emitted.</param>
            <returns>A reference to this instance after the emit operation has completed.</returns>
        </member>
        <member name="M:Neo.VM.ScriptBuilder.EmitSysCall(System.UInt32)">
            <summary>
            Emits an <see cref="T:Neo.VM.Instruction"/> with <see cref="F:Neo.VM.OpCode.SYSCALL"/>.
            </summary>
            <param name="api">The operand of <see cref="F:Neo.VM.OpCode.SYSCALL"/>.</param>
            <returns>A reference to this instance after the emit operation has completed.</returns>
        </member>
        <member name="M:Neo.VM.ScriptBuilder.ToArray">
            <summary>
            Converts the value of this instance to a byte array.
            </summary>
            <returns>A byte array contains the script.</returns>
        </member>
        <member name="T:Neo.VM.Slot">
            <summary>
            Used to store local variables, arguments and static fields in the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.Slot.Item(System.Int32)">
            <summary>
            Gets the item at the specified index in the slot.
            </summary>
            <param name="index">The zero-based index of the item to get.</param>
            <returns>The item at the specified index in the slot.</returns>
        </member>
        <member name="P:Neo.VM.Slot.Count">
            <summary>
            Gets the number of items in the slot.
            </summary>
        </member>
        <member name="M:Neo.VM.Slot.#ctor(Neo.VM.Types.StackItem[],Neo.VM.ReferenceCounter)">
            <summary>
            Creates a slot containing the specified items.
            </summary>
            <param name="items">The items to be contained.</param>
            <param name="referenceCounter">The reference counter to be used.</param>
        </member>
        <member name="M:Neo.VM.Slot.#ctor(System.Int32,Neo.VM.ReferenceCounter)">
            <summary>
            Create a slot of the specified size.
            </summary>
            <param name="count">Indicates the number of items contained in the slot.</param>
            <param name="referenceCounter">The reference counter to be used.</param>
        </member>
        <member name="T:Neo.VM.Types.Array">
            <summary>
            Represents an array or a complex object in the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.Types.Array.Item(System.Int32)">
            <summary>
            Get or set item in the array.
            </summary>
            <param name="index">The index of the item in the array.</param>
            <returns>The item at the specified index.</returns>
        </member>
        <member name="P:Neo.VM.Types.Array.Count">
            <summary>
            The number of items in the array.
            </summary>
        </member>
        <member name="M:Neo.VM.Types.Array.#ctor(System.Collections.Generic.IEnumerable{Neo.VM.Types.StackItem})">
            <summary>
            Create an array containing the specified items.
            </summary>
            <param name="items">The items to be included in the array.</param>
        </member>
        <member name="M:Neo.VM.Types.Array.#ctor(Neo.VM.ReferenceCounter,System.Collections.Generic.IEnumerable{Neo.VM.Types.StackItem})">
            <summary>
            Create an array containing the specified items. And make the array use the specified <see cref="T:Neo.VM.ReferenceCounter"/>.
            </summary>
            <param name="referenceCounter">The <see cref="T:Neo.VM.ReferenceCounter"/> to be used by this array.</param>
            <param name="items">The items to be included in the array.</param>
        </member>
        <member name="M:Neo.VM.Types.Array.Add(Neo.VM.Types.StackItem)">
            <summary>
            Add a new item at the end of the array.
            </summary>
            <param name="item">The item to be added.</param>
        </member>
        <member name="M:Neo.VM.Types.Array.RemoveAt(System.Int32)">
            <summary>
            Remove the item at the specified index.
            </summary>
            <param name="index">The index of the item to be removed.</param>
        </member>
        <member name="M:Neo.VM.Types.Array.Reverse">
            <summary>
            Reverse all items in the array.
            </summary>
        </member>
        <member name="T:Neo.VM.Types.Boolean">
            <summary>
            Represents a boolean (<see langword="true" /> or <see langword="false" />) value in the VM.
            </summary>
        </member>
        <member name="M:Neo.VM.Types.Boolean.#ctor(System.Boolean)">
            <summary>
            Create a new VM object representing the boolean type.
            </summary>
            <param name="value">The initial value of the object.</param>
        </member>
        <member name="T:Neo.VM.Types.Buffer">
            <summary>
            Represents a memory block that can be used for reading and writing in the VM.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.Buffer.InnerBuffer">
            <summary>
            The internal byte array used to store the actual data.
            </summary>
        </member>
        <member name="P:Neo.VM.Types.Buffer.Size">
            <summary>
            The size of the buffer.
            </summary>
        </member>
        <member name="M:Neo.VM.Types.Buffer.#ctor(System.Int32,System.Boolean)">
            <summary>
            Create a buffer of the specified size.
            </summary>
            <param name="size">The size of this buffer.</param>
            <param name="zeroInitialize">Indicates whether the created buffer is zero-initialized.</param>
        </member>
        <member name="M:Neo.VM.Types.Buffer.#ctor(System.ReadOnlySpan{System.Byte})">
            <summary>
            Create a buffer with the specified data.
            </summary>
            <param name="data">The data to be contained in this buffer.</param>
        </member>
        <member name="T:Neo.VM.Types.ByteString">
            <summary>
            Represents an immutable memory block in the VM.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.ByteString.Empty">
            <summary>
            An empty <see cref="T:Neo.VM.Types.ByteString"/>.
            </summary>
        </member>
        <member name="M:Neo.VM.Types.ByteString.#ctor(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Create a new <see cref="T:Neo.VM.Types.ByteString"/> with the specified data.
            </summary>
            <param name="data">The data to be contained in this <see cref="T:Neo.VM.Types.ByteString"/>.</param>
        </member>
        <member name="T:Neo.VM.Types.CompoundType">
            <summary>
            The base class for complex types in the VM.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.CompoundType.ReferenceCounter">
            <summary>
            The reference counter used to count the items in the VM object.
            </summary>
        </member>
        <member name="M:Neo.VM.Types.CompoundType.#ctor(Neo.VM.ReferenceCounter)">
            <summary>
            Create a new <see cref="T:Neo.VM.Types.CompoundType"/> with the specified reference counter.
            </summary>
            <param name="referenceCounter">The reference counter to be used.</param>
        </member>
        <member name="P:Neo.VM.Types.CompoundType.Count">
            <summary>
            The number of items in this VM object.
            </summary>
        </member>
        <member name="M:Neo.VM.Types.CompoundType.Clear">
            <summary>
            Remove all items from the VM object.
            </summary>
        </member>
        <member name="M:Neo.VM.Types.CompoundType.GetHashCode">
            <summary>
            The operation is not supported. Always throw <see cref="T:System.NotSupportedException"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">This method always throws the exception.</exception>
        </member>
        <member name="T:Neo.VM.Types.Integer">
            <summary>
            Represents an integer value in the VM.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.Integer.MaxSize">
            <summary>
            The maximum size of an integer in bytes.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.Integer.Zero">
            <summary>
            Represents the number 0.
            </summary>
        </member>
        <member name="M:Neo.VM.Types.Integer.#ctor(System.Numerics.BigInteger)">
            <summary>
            Create an integer with the specified value.
            </summary>
            <param name="value">The value of the integer.</param>
        </member>
        <member name="T:Neo.VM.Types.InteropInterface">
            <summary>
            Represents an interface used to interoperate with the outside of the the VM.
            </summary>
        </member>
        <member name="M:Neo.VM.Types.InteropInterface.#ctor(System.Object)">
            <summary>
            Create an interoperability interface that wraps the specified <see cref="T:System.Object"/>.
            </summary>
            <param name="value">The wrapped <see cref="T:System.Object"/>.</param>
        </member>
        <member name="T:Neo.VM.Types.Map">
            <summary>
            Represents an ordered collection of key-value pairs in the VM.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.Map.MaxKeySize">
            <summary>
            Indicates the maximum size of keys in bytes.
            </summary>
        </member>
        <member name="P:Neo.VM.Types.Map.Item(Neo.VM.Types.PrimitiveType)">
            <summary>
            Gets or sets the element that has the specified key in the map.
            </summary>
            <param name="key">The key to locate.</param>
            <returns>The element that has the specified key in the map.</returns>
        </member>
        <member name="P:Neo.VM.Types.Map.Keys">
            <summary>
            Gets an enumerable collection that contains the keys in the map.
            </summary>
        </member>
        <member name="P:Neo.VM.Types.Map.Values">
            <summary>
            Gets an enumerable collection that contains the values in the map.
            </summary>
        </member>
        <member name="M:Neo.VM.Types.Map.#ctor(Neo.VM.ReferenceCounter)">
            <summary>
            Create a new map with the specified reference counter.
            </summary>
            <param name="referenceCounter">The reference counter to be used.</param>
        </member>
        <member name="M:Neo.VM.Types.Map.ContainsKey(Neo.VM.Types.PrimitiveType)">
            <summary>
            Determines whether the map contains an element that has the specified key.
            </summary>
            <param name="key">The key to locate.</param>
            <returns>
            <see langword="true" /> if the map contains an element that has the specified key;
            otherwise, <see langword="false" />.
            </returns>
        </member>
        <member name="M:Neo.VM.Types.Map.Remove(Neo.VM.Types.PrimitiveType)">
            <summary>
            Removes the element with the specified key from the map.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            <see langword="true" /> if the element is successfully removed;
            otherwise, <see langword="false"/>.
            This method also returns <see langword="false"/> if <paramref name="key"/> was not found in the original map.
            </returns>
        </member>
        <member name="M:Neo.VM.Types.Map.TryGetValue(Neo.VM.Types.PrimitiveType,Neo.VM.Types.StackItem@)">
            <summary>
            Gets the value that is associated with the specified key.
            </summary>
            <param name="key">The key to locate.</param>
            <param name="value">
            When this method returns, the value associated with the specified key, if the key is found;
            otherwise, <see langword="null"/>.
            </param>
            <returns>
            <see langword="true" /> if the map contains an element that has the specified key;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:Neo.VM.Types.Null">
            <summary>
            Represents <see langword="null"/> in the VM.
            </summary>
        </member>
        <member name="T:Neo.VM.Types.Pointer">
            <summary>
            Represents the instruction pointer in the VM, used as the target of jump instructions.
            </summary>
        </member>
        <member name="P:Neo.VM.Types.Pointer.Script">
            <summary>
            The <see cref="T:Neo.VM.Script"/> object containing this pointer.
            </summary>
        </member>
        <member name="P:Neo.VM.Types.Pointer.Position">
            <summary>
            The position of the pointer in the script.
            </summary>
        </member>
        <member name="M:Neo.VM.Types.Pointer.#ctor(Neo.VM.Script,System.Int32)">
            <summary>
            Create a code pointer with the specified script and position.
            </summary>
            <param name="script">The <see cref="T:Neo.VM.Script"/> object containing this pointer.</param>
            <param name="position">The position of the pointer in the script.</param>
        </member>
        <member name="T:Neo.VM.Types.PrimitiveType">
            <summary>
            The base class for primitive types in the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.Types.PrimitiveType.Size">
            <summary>
            The size of the VM object in bytes.
            </summary>
        </member>
        <member name="M:Neo.VM.Types.PrimitiveType.GetHashCode">
            <summary>
            Get the hash code of the VM object, which is used for key comparison in the <see cref="T:Neo.VM.Types.Map"/>.
            </summary>
            <returns>The hash code of this VM object.</returns>
        </member>
        <member name="T:Neo.VM.Types.StackItem">
            <summary>
            The base class for all types in the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.Types.StackItem.True">
            <summary>
            Represents <see langword="true"/> in the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.Types.StackItem.False">
            <summary>
            Represents <see langword="false"/> in the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.Types.StackItem.Null">
            <summary>
            Represents <see langword="null"/> in the VM.
            </summary>
        </member>
        <member name="P:Neo.VM.Types.StackItem.IsNull">
            <summary>
            Indicates whether the object is <see cref="P:Neo.VM.Types.StackItem.Null"/>.
            </summary>
        </member>
        <member name="P:Neo.VM.Types.StackItem.Type">
            <summary>
            The type of this VM object.
            </summary>
        </member>
        <member name="M:Neo.VM.Types.StackItem.ConvertTo(Neo.VM.Types.StackItemType)">
            <summary>
            Convert the VM object to the specified type.
            </summary>
            <param name="type">The type to be converted to.</param>
            <returns>The converted object.</returns>
        </member>
        <member name="M:Neo.VM.Types.StackItem.DeepCopy(System.Boolean)">
            <summary>
            Copy the object and all its children.
            </summary>
            <returns>The copied object.</returns>
        </member>
        <member name="M:Neo.VM.Types.StackItem.FromInterface(System.Object)">
            <summary>
            Wrap the specified <see cref="T:System.Object"/> and return an <see cref="T:Neo.VM.Types.InteropInterface"/> containing the <see cref="T:System.Object"/>.
            </summary>
            <param name="value">The wrapped <see cref="T:System.Object"/>.</param>
            <returns></returns>
        </member>
        <member name="M:Neo.VM.Types.StackItem.GetBoolean">
            <summary>
            Get the boolean value represented by the VM object.
            </summary>
            <returns>The boolean value represented by the VM object.</returns>
        </member>
        <member name="M:Neo.VM.Types.StackItem.GetInteger">
            <summary>
            Get the integer value represented by the VM object.
            </summary>
            <returns>The integer value represented by the VM object.</returns>
        </member>
        <member name="M:Neo.VM.Types.StackItem.GetInterface``1">
            <summary>
            Get the <see cref="T:System.Object"/> wrapped by this interface and convert it to the specified type.
            </summary>
            <typeparam name="T">The type to convert to.</typeparam>
            <returns>The wrapped <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neo.VM.Types.StackItem.GetSpan">
            <summary>
            Get the readonly span used to read the VM object data.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Neo.VM.Types.StackItem.GetString">
            <summary>
            Get the <see cref="T:System.String"/> value represented by the VM object.
            </summary>
            <returns>The <see cref="T:System.String"/> value represented by the VM object.</returns>
        </member>
        <member name="T:Neo.VM.Types.StackItemType">
            <summary>
            An enumeration representing the types in the VM.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.StackItemType.Any">
            <summary>
            Represents any type.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.StackItemType.Pointer">
            <summary>
            Represents a code pointer.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.StackItemType.Boolean">
            <summary>
            Represents the boolean (<see langword="true" /> or <see langword="false" />) type.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.StackItemType.Integer">
            <summary>
            Represents an integer.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.StackItemType.ByteString">
            <summary>
            Represents an immutable memory block.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.StackItemType.Buffer">
            <summary>
            Represents a memory block that can be used for reading and writing.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.StackItemType.Array">
            <summary>
            Represents an array or a complex object.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.StackItemType.Struct">
            <summary>
            Represents a structure.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.StackItemType.Map">
            <summary>
            Represents an ordered collection of key-value pairs.
            </summary>
        </member>
        <member name="F:Neo.VM.Types.StackItemType.InteropInterface">
            <summary>
            Represents an interface used to interoperate with the outside of the the VM.
            </summary>
        </member>
        <member name="T:Neo.VM.Types.Struct">
            <summary>
            Represents a structure in the VM.
            </summary>
        </member>
        <member name="M:Neo.VM.Types.Struct.#ctor(System.Collections.Generic.IEnumerable{Neo.VM.Types.StackItem})">
            <summary>
            Create a structure with the specified fields.
            </summary>
            <param name="fields">The fields to be included in the structure.</param>
        </member>
        <member name="M:Neo.VM.Types.Struct.#ctor(Neo.VM.ReferenceCounter,System.Collections.Generic.IEnumerable{Neo.VM.Types.StackItem})">
            <summary>
            Create a structure with the specified fields. And make the structure use the specified <see cref="T:Neo.VM.ReferenceCounter"/>.
            </summary>
            <param name="referenceCounter">The <see cref="T:Neo.VM.ReferenceCounter"/> to be used by this structure.</param>
            <param name="fields">The fields to be included in the structure.</param>
        </member>
        <member name="M:Neo.VM.Types.Struct.Clone(Neo.VM.ExecutionEngineLimits)">
            <summary>
            Create a new structure with the same content as this structure. All nested structures will be copied by value.
            </summary>
            <param name="limits">Execution engine limits</param>
            <returns>The copied structure.</returns>
        </member>
        <member name="M:Neo.VM.Utility.GetBitLength(System.Numerics.BigInteger)">
            <summary>
            Gets the number of bits required for shortest two's complement representation of the current instance without the sign bit.
            </summary>
            <returns>The minimum non-negative number of bits in two's complement notation without the sign bit.</returns>
            <remarks>This method returns 0 if the value of current object is equal to <see cref="P:System.Numerics.BigInteger.Zero"/> or <see cref="P:System.Numerics.BigInteger.MinusOne"/>. For positive integers the return value is equal to the ordinary binary representation string length.</remarks>
        </member>
        <member name="T:Neo.VM.VMState">
            <summary>
            Indicates the status of the VM.
            </summary>
        </member>
        <member name="F:Neo.VM.VMState.NONE">
            <summary>
            Indicates that the execution is in progress or has not yet begun.
            </summary>
        </member>
        <member name="F:Neo.VM.VMState.HALT">
            <summary>
            Indicates that the execution has been completed successfully.
            </summary>
        </member>
        <member name="F:Neo.VM.VMState.FAULT">
            <summary>
            Indicates that the execution has ended, and an exception that cannot be caught is thrown.
            </summary>
        </member>
        <member name="F:Neo.VM.VMState.BREAK">
            <summary>
            Indicates that a breakpoint is currently being hit.
            </summary>
        </member>
        <member name="T:Neo.VM.VMUnhandledException">
            <summary>
            Represents an unhandled exception in the VM.
            Thrown when there is an exception in the VM that is not caught by any script.
            </summary>
        </member>
        <member name="P:Neo.VM.VMUnhandledException.ExceptionObject">
            <summary>
            The unhandled exception in the VM.
            </summary>
        </member>
        <member name="M:Neo.VM.VMUnhandledException.#ctor(Neo.VM.Types.StackItem)">
            <summary>
            Initializes a new instance of the <see cref="T:Neo.VM.VMUnhandledException"/> class.
            </summary>
            <param name="ex">The unhandled exception in the VM.</param>
        </member>
    </members>
</doc>
