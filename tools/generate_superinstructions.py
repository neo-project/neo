#!/usr/bin/env python3
"""
Utility to turn the planner output (vm-superinstructions.json) into a C# helper.

Example:
    python tools/generate_superinstructions.py \
        --input plugins/OTelPlugin/profiles/vm-superinstructions.json \
        --output src/Neo.VM/JumpTable.SuperInstructions.generated.cs \
        --min-ratio 0.10 --max-count 24
"""

from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path
from textwrap import indent


HEADER = """// <auto-generated />
// This file was produced by tools/generate_superinstructions.py
// Source: {source}

using System;

namespace Neo.VM
{{
    /// <summary>
    /// Generated super-instruction suggestions captured from runtime telemetry.
    /// Feed these sequences into your JIT or JumpTable extensions.
    /// </summary>
    internal static class GeneratedSuperInstructions
    {{
        internal static ReadOnlySpan<Entry> Entries => new Entry[]
        {{
{entries}
        }};

        internal readonly record struct Entry(
            string Script,
            ReadOnlyMemory<OpCode> Sequence,
            double HitRatio,
            int HitCount,
            DateTimeOffset LastUpdatedUtc);
    }}
}}
"""


def parse_args(argv: list[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--input", required=True, type=Path, help="Path to vm-superinstructions.json")
    parser.add_argument("--output", required=True, type=Path, help="Destination C# file")
    parser.add_argument("--min-ratio", type=float, default=0.05, help="Minimum hit ratio to keep")
    parser.add_argument("--max-count", type=int, default=32, help="Maximum number of entries to emit")
    parser.add_argument("--script", type=str, default=None, help="Filter to a specific script hash")
    return parser.parse_args(argv)


def load_entries(path: Path) -> list[dict]:
    data = json.loads(path.read_text(encoding="utf-8"))
    entries = data.get("entries") or []
    if not isinstance(entries, list):
        raise ValueError(f"Unexpected JSON structure in {path}")
    return entries


def format_entry(entry: dict) -> str:
    sequence = entry["sequence"].split()
    opcode_list = ", ".join(f"OpCode.{op}" for op in sequence)
    return (
        "            new Entry(\n"
        f'                "{entry["script"]}",\n'
        f"                new[] {{ {opcode_list} }},\n"
        f"                {entry['hit_ratio']},\n"
        f"                {entry['hit_count']},\n"
        f"                DateTimeOffset.Parse(\"{entry['last_updated_utc']}\", null, System.Globalization.DateTimeStyles.RoundtripKind))"
    )


def main(argv: list[str]) -> int:
    args = parse_args(argv)
    entries = load_entries(args.input)
    if args.script:
        entries = [e for e in entries if e.get("script", "").lower() == args.script.lower()]
    entries = [
        e for e in entries
        if float(e.get("hit_ratio", 0.0)) >= args.min_ratio
    ]
    entries.sort(key=lambda e: (-e.get("hit_ratio", 0.0), -e.get("hit_count", 0)))
    entries = entries[: max(1, args.max_count)]

    if not entries:
        print("No entries satisfied the provided filters; nothing to generate.", file=sys.stderr)
        return 1

    entry_block = ",\n".join(format_entry(e) for e in entries)
    output = HEADER.format(
        source=args.input.as_posix(),
        entries=entry_block,
    )
    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(output, encoding="utf-8")
    print(f"Wrote {len(entries)} entries to {args.output}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
