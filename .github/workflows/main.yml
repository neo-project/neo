name: .NET Core Test and Publish

on:
  push:
    branches: [master-n3]
  pull_request:

env:
  DOTNET_VERSION: 10.0.x

jobs:

  Check-Vulnerable:
    name: Scan for Vulnerable Dependencies
    timeout-minutes: 15
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
    - name: Checkout
      uses: actions/checkout@v5
    - name: Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    - name: Restore
      run: dotnet restore
    - name: Scan for Vulnerable Dependencies
      run: dotnet list package --vulnerable --include-transitive

  Test:
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
    - name: Checkout
      uses: actions/checkout@v5
    - name: Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key         : ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: ${{ runner.os }}-nuget-
    - name: Check Format (*.cs)
      if: matrix.os == 'ubuntu-latest'
      run: dotnet format --verify-no-changes --verbosity diagnostic
    - name: Test (ALL OS)
      if: matrix.os != 'ubuntu-latest'
      run: |
        dotnet test -p:GITHUB_ACTIONS=true
    - name: Test (ubuntu)
      if: matrix.os == 'ubuntu-latest'
      run: |
        find tests -name *.csproj | xargs -I % dotnet add % package coverlet.msbuild
        dotnet test /p:GITHUB_ACTIONS=true /p:CollectCoverage=true /p:CoverletOutput='${{ github.workspace }}/TestResults/coverage/' /p:MergeWith='${{ github.workspace }}/TestResults/coverage/coverage.json' /p:CoverletOutputFormat=\"lcov,json\" -m:1
    - name: Coveralls
      if: matrix.os == 'ubuntu-latest'
      uses: coverallsapp/github-action@v2
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        format: lcov
        file: ${{ github.workspace }}/TestResults/coverage/coverage.info

  PublishMyGet:
    if: github.ref == 'refs/heads/master-n3' && startsWith(github.repository, 'neo-project/')
    needs: [Test]
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v5
      with:
        fetch-depth: 0
    - name: Setup .NET Core
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    - name: Set Version
      run: git rev-list --count HEAD | xargs printf 'CI%05d' | xargs -I{} echo 'VERSION_SUFFIX={}' >> $GITHUB_ENV
    - name : Pack (Everything)
      run: dotnet pack -c Debug -o out --include-source --version-suffix ${{ env.VERSION_SUFFIX }}
    - name: Delete old MyGet CI packages
      run: |
        set -euo pipefail

        MYGET_API_URL="https://www.myget.org/F/neo/api/v2/package"
        MYGET_FLAT_CONTAINER_URL="https://www.myget.org/F/neo/api/v3/flatcontainer"

        declare -A keep_versions=()
        for package_file in out/*.nupkg; do
          [[ "$package_file" == *.symbols.nupkg ]] && continue

          nuspec_path=$(unzip -Z1 "$package_file" | grep -E '\.nuspec$' | head -n 1 || true)
          [[ -z "$nuspec_path" ]] && continue

          nuspec_content=$(unzip -p "$package_file" "$nuspec_path" | tr -d '\r')
          package_id=$(echo "$nuspec_content" | sed -n 's:.*<id>\([^<]*\)</id>.*:\1:p' | head -n 1)
          package_version=$(echo "$nuspec_content" | sed -n 's:.*<version>\([^<]*\)</version>.*:\1:p' | head -n 1)

          [[ -z "$package_id" || -z "$package_version" ]] && continue
          keep_versions["$package_id"]="$package_version"
        done

        for package_id in "${!keep_versions[@]}"; do
          current_version="${keep_versions[$package_id]}"
          package_id_lower=$(echo "$package_id" | tr '[:upper:]' '[:lower:]')
          index_url="${MYGET_FLAT_CONTAINER_URL}/${package_id_lower}/index.json"

          if ! versions_json=$(curl -fsSL "$index_url"); then
            echo "No existing versions for ${package_id}; skipping cleanup."
            continue
          fi

          mapfile -t ci_versions < <(echo "$versions_json" | jq -r '.versions[]? | select(test("-CI[0-9]+$"))')

          if [[ ${#ci_versions[@]} -eq 0 ]]; then
            echo "No CI versions found for ${package_id}; skipping cleanup."
            continue
          fi

          keep_v3=$(
            {
              echo "$versions_json" | jq -r '.versions[]? | select(test("^3\\..*-CI[0-9]+$"))'
              [[ "$current_version" =~ ^3\..*-CI[0-9]+$ ]] && echo "$current_version"
            } | awk 'NF' | sort -V | tail -n 1
          )

          keep_v4=$(
            {
              echo "$versions_json" | jq -r '.versions[]? | select(test("^4\\..*-CI[0-9]+$"))'
              [[ "$current_version" =~ ^4\..*-CI[0-9]+$ ]] && echo "$current_version"
            } | awk 'NF' | sort -V | tail -n 1
          )

          declare -A keep_ci_versions=()
          [[ -n "$keep_v3" ]] && keep_ci_versions["$keep_v3"]=1
          [[ -n "$keep_v4" ]] && keep_ci_versions["$keep_v4"]=1

          if [[ ${#keep_ci_versions[@]} -eq 0 ]]; then
            echo "No 3.x/4.x CI versions found for ${package_id}; skipping cleanup."
            continue
          fi

          echo "Keeping ${package_id} 3.x=${keep_v3:-none}, 4.x=${keep_v4:-none}. Removing other CI versions."

          for ci_version in "${ci_versions[@]}"; do
            if [[ -n "${keep_ci_versions[$ci_version]:-}" ]]; then
              continue
            fi

            delete_url="${MYGET_API_URL}/${package_id}/${ci_version}"
            status_code=$(curl -sS -o /tmp/myget-delete-response.txt -w '%{http_code}' -X DELETE "$delete_url" -H "X-NuGet-ApiKey: ${MYGET_TOKEN}")

            case "$status_code" in
              2*)
                echo "Deleted ${package_id} ${ci_version}"
                ;;
              404)
                echo "${package_id} ${ci_version} was already deleted"
                ;;
              *)
                echo "Failed deleting ${package_id} ${ci_version} (HTTP ${status_code})"
                cat /tmp/myget-delete-response.txt
                exit 1
                ;;
            esac
          done
        done
      env:
        MYGET_TOKEN: ${{ secrets.MYGET_TOKEN }}
    - name: Publish to myGet
      run: dotnet nuget push out/*.nupkg -s https://www.myget.org/F/neo/api/v2/package -k ${MYGET_TOKEN} --skip-duplicate -ss https://www.myget.org/F/neo/symbols/api/v2/package -sk ${MYGET_TOKEN}
      env:
        MYGET_TOKEN: ${{ secrets.MYGET_TOKEN }}
        
  Release:
    if: github.ref == 'refs/heads/master-n3' && startsWith(github.repository, 'neo-project/')
    needs: Test
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v5
    - name: Get version
      id: get_version
      run: |
        sudo apt install xmlstarlet
        find src -name Directory.Build.props | xargs xmlstarlet sel -N i=http://schemas.microsoft.com/developer/msbuild/2003 -t -v "concat('version=v',//i:Version/text())" | xargs echo >> $GITHUB_OUTPUT
    - name: Check tag
      if: steps.get_version.outputs.version != 'v' && startsWith(steps.get_version.outputs.version, 'v')
      id: check_tag
      run: curl -s -I ${{ format('https://github.com/{0}/releases/tag/{1}', github.repository, steps.get_version.outputs.version) }} | head -n 1 | cut -d$' ' -f2 | xargs printf "statusCode=%s" | xargs echo >> $GITHUB_OUTPUT
    - name: Create release
      if: steps.check_tag.outputs.statusCode == '404'
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.get_version.outputs.version }}
        release_name: ${{ steps.get_version.outputs.version }}
        prerelease: ${{ contains(steps.get_version.outputs.version, '-') }}
    - name: Setup .NET Core
      if: steps.check_tag.outputs.statusCode == '404'
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    - name: Publish to NuGet
      if: steps.check_tag.outputs.statusCode == '404'
      run: |
        dotnet pack -o out -c Release
        dotnet nuget push out/*.nupkg -s https://api.nuget.org/v3/index.json -k ${NUGET_TOKEN}
      env:
        NUGET_TOKEN: ${{ secrets.NUGET_TOKEN }}
